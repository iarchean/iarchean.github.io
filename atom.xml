<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Archean&#39;s Blog</title>
  
  <subtitle>Knowing and Doing.</subtitle>
  <link href="https://archeanz.com/atom.xml" rel="self"/>
  
  <link href="https://archeanz.com/"/>
  <updated>2021-06-30T10:27:15.459Z</updated>
  <id>https://archeanz.com/</id>
  
  <author>
    <name>Archean Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>F5 可用性研究以及使用 Zabbix 监控 F5</title>
    <link href="https://archeanz.com/2019/03/24/Moniting-F5-with-Zabbix/"/>
    <id>https://archeanz.com/2019/03/24/Moniting-F5-with-Zabbix/</id>
    <published>2019-03-24T08:56:33.000Z</published>
    <updated>2021-06-30T10:27:15.459Z</updated>
    
    <content type="html"><![CDATA[<p>目前部门的各类系统大部分都使用 F5 发布 VIP 提供给用户使用，而之前对 F5 的监控基本没有，本文诣在研究如何通过 SNMP 的方式读取 F5 的各类状态、性能指标，以及什么样的状况需要去告警。</p><span id="more"></span><p>将 F5 的 OID 模版导入到 Zabbix Server 的 <code>/usr/share/snmp/mibs</code> 目录中之后，即可使用 <code>snmpwalk</code> 命令请求 F5 的各项状态。在请求时，大部分值均需要增加 OID 前缀，本文基本只涉及 <code>F5-BIGIP-LOCAL-MIB.txt</code> 这个模版中的内容，所以请求命令的样子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snmpwalk -v2c -c public F5.hostname.or.IP F5-BIGIP-LOCAL-MIB::ltmPoolMemberMonitorStatus</span><br></pre></td></tr></table></figure><h2 id="F5-Status"><a href="#F5-Status" class="headerlink" title="F5 Status"></a>F5 Status</h2><p>F5 自身状态中需要关注的一个是 CPU、内存使用率，另外就是主备同步状态及故障转移状态。</p><h3 id="Failover-Status"><a href="#Failover-Status" class="headerlink" title="Failover Status"></a>Failover Status</h3><p>待补充</p><h3 id="ConfigSync-Status"><a href="#ConfigSync-Status" class="headerlink" title="ConfigSync Status"></a>ConfigSync Status</h3><p>待补充</p><h2 id="Virtual-Server"><a href="#Virtual-Server" class="headerlink" title="Virtual Server"></a>Virtual Server</h2><p>Virtual Server（VS）是 F5 对外提供访问的入口，是 Local Traffic Manager（LTM）中最外层的对象，一旦 Down 掉了整体服务将不可用。这也是除 F5 本身挂掉以外最严重的问题。</p><h3 id="VS-Status"><a href="#VS-Status" class="headerlink" title="VS Status"></a>VS Status</h3><p>VS 状态对应的一个 OID 值是 <code>ltmVsStatusAvailState</code>，这代表了 VS 可用状态。除此之外，还需要关注 VS 的运营状态，其 OID 值是 <code>ltmVsStatusEnabledState</code>。</p><table><thead><tr><th align="center">ICON</th><th>可用状态</th><th>运营状态</th><th>可用状态代码</th><th>运营状态代码</th><th>描述</th></tr></thead><tbody><tr><td align="center"><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/35fu3.png"></td><td>Avaliable</td><td>Enabled</td><td>GREEN（0）</td><td>ENABLED(1)</td><td>VS 已启用且池成员健康检查正常</td></tr><tr><td align="center"><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/jxv98.png"></td><td>Unknown</td><td>Enabled</td><td>BLUE（4）</td><td>ENABLED(1)</td><td>VS 已启用但没有成员</td></tr><tr><td align="center"><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/y50yv.png"></td><td>Offline</td><td>Enabled</td><td>RED（3）</td><td>ENABLED(1)</td><td>VS 已启用但池成员健康检查异常</td></tr><tr><td align="center"><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/i5ugu.png"></td><td>Avaliable</td><td>Disabled</td><td>GREEN（0）</td><td>DISABLED(2)</td><td>VS 已禁用且池成员健康检查正常</td></tr><tr><td align="center"><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/dc7m3.png"></td><td>Unknown</td><td>Disabled</td><td>BLUE（4）</td><td>DISABLED(2)</td><td>VS 已禁用但没有成员</td></tr><tr><td align="center"><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/x46rg.png"></td><td>Offline</td><td>Disabled</td><td>RED（3）</td><td>DISABLED(2)</td><td>VS 已禁用且池成员健康检查异常</td></tr></tbody></table><p><code>RED(3) </code>状态应该是我们最需要关注的状况。如果运营状态为 <code>Enabled</code> 且可用状态是 <code>Offline</code>，即代表此 VS 出现了不可用的状况。</p><h3 id="VS-Statistics"><a href="#VS-Statistics" class="headerlink" title="VS Statistics"></a>VS Statistics</h3><p>VS Statistics 中比较需要关注的包括流量、连接数、请求次数。分别对应下面几个 OID 值：</p><ul><li>ltmVirtualServStatClientCurConns</li><li>ltmVirtualServStatTotRequests</li><li>ltmVirtualServStatClientBytesOut</li><li>ltmVirtualServStatClientBytesIn</li></ul><h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h2><p>Pool 是 VS 的资源池，通过某种负载均衡方式将请求转发至池中的 Member。</p><h3 id="Pool-Status"><a href="#Pool-Status" class="headerlink" title="Pool Status"></a>Pool Status</h3><p>资源池也是有状态的，但只有可用状态，无运营状态。相应的，其 OID 值是 <code>ltmPoolStatusAvailState</code>，池的状态同样列举如下：</p><table><thead><tr><th align="center">ICON</th><th>可用状态</th><th>可用状态代码</th><th>描述</th></tr></thead><tbody><tr><td align="center"><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/35fu3.png"></td><td>Avaliable</td><td>GREEN（0）</td><td>池成员健康检查正常</td></tr><tr><td align="center"><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/jxv98.png"></td><td>Unknown</td><td>BLUE（4）</td><td>池成员健康检查状态未知</td></tr><tr><td align="center"><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/y50yv.png"></td><td>Offline</td><td>RED（3）</td><td>池成员健康检查异常</td></tr></tbody></table><p>关注资源池的状态意义不太明显，因为就目前的服务发布架构（一个 VS 对应一个 Pool），池状态变为 Offline 时，VS 一定也会变成 Offline。所以基本上只需要关注 Pool 的统计数字即可。</p><h3 id="Pool-Statistics"><a href="#Pool-Statistics" class="headerlink" title="Pool Statistics"></a>Pool Statistics</h3><p>Pool Statistics 中的统计数字可以为整体运营数据提供另一个纬度的指标，意义不如 VS Statistics 那样明显，对应的 OID 值如下：</p><ul><li>ltmPoolLbMode</li><li>ltmPoolStatusAvailState </li><li>ltmPoolActiveMemberCnt</li><li>ltmPoolStatServerCurConns</li><li>ltmPoolStatTotRequests</li><li>ltmPoolStatServerBytesOut</li><li>ltmPoolStatServerBytesIn</li></ul><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node 是 LTM 中最小的粒度，对应的是实际的服务器（Real Server or RS），Node 是 Pool 中的成员，</p><h3 id="Node-Status"><a href="#Node-Status" class="headerlink" title="Node Status"></a>Node Status</h3><p>这里讨论的 Node 的状态只包括运营状态 <code>ltmNodeAddrStatusEnabledState</code>，因为在现存架构中，Node 的可用状态必须结合 Pool 的健康检查方式来看。Node 可用状态也可以单独设定，但不在本文的讨论范围内。</p><table><thead><tr><th align="center">ICON</th><th>运营状态</th><th>运营状态代码</th><th>描述</th></tr></thead><tbody><tr><td align="center">黑色</td><td>Disabled</td><td>disabled(1)</td><td>已禁用</td></tr><tr><td align="center">其他</td><td>Enabled</td><td>enabled(0)</td><td>已启用</td></tr></tbody></table><h3 id="Node-Statistics"><a href="#Node-Statistics" class="headerlink" title="Node Statistics"></a>Node Statistics</h3><p>Node 的统计数字仅仅作为单机流量的参考，主要包括下面几个 OID 值：</p><ul><li>ltmNodeAddrStatServerBytesIn</li><li>ltmNodeAddrStatServerBytesOut</li><li>ltmNodeAddrStatServerCurConns</li></ul><h2 id="Pool-Member-Monitor-Status"><a href="#Pool-Member-Monitor-Status" class="headerlink" title="Pool Member Monitor Status"></a>Pool Member Monitor Status</h2><p>其实相比 Pool Status，更有用的应该是 Pool Member Monitor Status，由于所有的业务均由 F5 统一发布，所以 F5 有着最为敏锐、实时的健康检查机制：一旦发布的服务端口不可用，或延迟较高，则马上将其在 Pool 中排除，以免将用户请求分发到问题节点，从而引起访问超时甚至不可用。</p><p>于是，监控 F5 的健康检查状态，比直接使用 Zabbix 的端口检测更加直接。但是，由于 F5 自己会排除问题节点，所以单纯的节点故障不会引起整个服务的异常。此监控产生的告警仅仅需要知会管理员，按照我的监控定义，生成二级告警即可。</p><table><thead><tr><th align="center">ICON</th><th>可用状态</th><th>可用状态代码</th><th>描述</th></tr></thead><tbody><tr><td align="center"><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/35fu3.png"></td><td>Availabe</td><td>up(4)</td><td>可用</td></tr><tr><td align="center"><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/y50yv.png"></td><td>Offline</td><td>down (19)</td><td>不可用</td></tr><tr><td align="center"><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/x46rg.png"></td><td>Forced Down</td><td>forcedDown (20)</td><td>已禁用且不可用</td></tr></tbody></table><h3 id="Pool-Active-Member-Percentage"><a href="#Pool-Active-Member-Percentage" class="headerlink" title="Pool Active Member Percentage"></a>Pool Active Member Percentage</h3><p>目前的服务发布机制，每个 Pool 中的服务器数量均基本大于 3 个，相比单纯的 Member Status，关注 Pool 中活动节点的比例显得更为重要。</p><p>服务架构设计之初，即考虑到了其冗余性，极端状况下，允许一半的节点停止服务，于是</p><p>Active Member Percentage 可以通过活动节点数量 <code>ltmPoolActiveMemberCnt</code> 除以全部节点数量 <code>ltmPoolMemberCnt</code> 来计算出来。</p><h2 id="Alarm-Policy"><a href="#Alarm-Policy" class="headerlink" title="Alarm Policy"></a>Alarm Policy</h2><p>根据上述内容，我制定出 F5 监控的告警策略，分为一、二、三级告警，分别对应 High、Average、Warning 三个内置告警级别：</p><h3 id="High"><a href="#High" class="headerlink" title="High"></a>High</h3><ul><li>VS Offline</li><li>Pool Active Member Percentage &lt; 50%</li><li>CPU Usage &gt; 80%</li></ul><h3 id="Average"><a href="#Average" class="headerlink" title="Average"></a>Average</h3><ul><li>Pool Member Monitor Status Offline</li><li>Failover Status Failed</li><li>Pool Offline</li></ul><h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h3><ul><li>Pool Member Monitor Status Disabled</li><li>ConfigSync Status NotSync</li><li>Node Disabled</li><li>VS Disabled</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前部门的各类系统大部分都使用 F5 发布 VIP 提供给用户使用，而之前对 F5 的监控基本没有，本文诣在研究如何通过 SNMP 的方式读取 F5 的各类状态、性能指标，以及什么样的状况需要去告警。&lt;/p&gt;</summary>
    
    
    
    <category term="Moniting" scheme="https://archeanz.com/categories/Moniting/"/>
    
    <category term="F5" scheme="https://archeanz.com/categories/Moniting/F5/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 Zabbix 监控 Exchange Server 的数据库</title>
    <link href="https://archeanz.com/2019/03/17/moniting-exchange-server-with-zabbix/"/>
    <id>https://archeanz.com/2019/03/17/moniting-exchange-server-with-zabbix/</id>
    <published>2019-03-16T15:12:06.000Z</published>
    <updated>2021-06-30T10:27:15.459Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章里我想要分享一下 Exchange Server 2016 数据库状态以及数据库使用量的监控方法，经过几次修改和迭代，目前我使用的是 Zabbix 3.2 对数据库进行统一、自动化、动态自配置的监控。</p><span id="more"></span><h2 id="主要解决了哪些问题？"><a href="#主要解决了哪些问题？" class="headerlink" title="主要解决了哪些问题？"></a>主要解决了哪些问题？</h2><p>当前主流的监控平台，如 Zabbix、Prometheus，微软自家的 SCOM，还有古董 Cacti 我都已经进行过或多或少的尝试，最终选定 Zabbix 作为 Exchange Server 的统一监控平台，主要原因是它高自由度的配置、分布式部署方式以及丰富的 API 接口，便于针对性的修改和获取数据用于统一展示，图表功能一般但是够用，好在可以通过 API 将数据取出来做二次处理。</p><p>在花费了大量时间优化调整监控项、触发器以及告警策略之后，只剩最后一块难啃的石头，也就是今天讨论的数据库状态监控。</p><h2 id="Exchange-数据库监控的演变"><a href="#Exchange-数据库监控的演变" class="headerlink" title="Exchange 数据库监控的演变"></a>Exchange 数据库监控的演变</h2><p>集团 Exchange 数据库的监控经历了 3 个主要阶段：</p><ul><li>最初是根据一个数据库列表文档跑脚本，通过 <code>Test-MAPIConnectivity</code> 检测数据库是否挂载，发送短信来告警。手工维护难免造成遗漏；</li><li>在经历了一个由于主备关系问题导致的集群崩溃事故之后，第二阶段的脚本使用 <code>Get-MailboxDatabaseCopyStatus</code> 来侦测数据库状态。另外可以自动的检测新加入的数据库；</li><li>但是数据库大小、人数、可用空间、主备关系这些东西没有直观的展示出来，于是进化到第三阶段，Zabbix 统一监控展示。</li></ul><h2 id="Zabbix-监控数据库思路"><a href="#Zabbix-监控数据库思路" class="headerlink" title="Zabbix 监控数据库思路"></a>Zabbix 监控数据库思路</h2><p>目前所有的邮件服务器均已加入 Zabbix 做基础的硬件信息和服务、性能指标的监控。</p><p>使用 Zabbix 发现服务，通过一个 Powershell 脚本( <code>Get-ExchangeDBDiscovery.ps1</code> )获取到每台服务器中的数据库信息，写入到服务器监控项中；为了减少抓取延迟，服务器本地每分钟会执行另一个 Powershell 脚本(<code>Get-ExchangeDBStatus.ps1</code>)，将所需要的数据库信息全部写入到脚本执行目录中的子目录 <code>DBStatus</code> 中；Zabbix 中的服务器，通过执行自定义命令从 CSV 文件中获取字段值，完成数据收集；如果数据库被卸载，则触发一级告警，直接电话通知我。若数据库同步状态异常，则触发二级告警，使用集团内部 IM 软件告诉我。</p><h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><p>由于我的目标是做成全自动监控，而且数据库数量实在太多（集团接近 50000 人，分了 300 多个数据库）所以其中比较困难的点在于：</p><ol><li>由于数据库分 Active 和 Passive，会在两台成对的服务器中各生成一个监控项，降低 Zabbix 执行效率，所以必须分开</li><li>由于 Active 和 Passive 会切换，如果监控项也跟着切换，会造成临时性数据获取失败</li><li>主备关系切换同样会导致挂载信息和复制信息的混乱</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>对于第一点和第二点，通过 <code>Get-MailboxDatabaseCopyStatus</code> 中数据库挂载优先级字段 <code>ActivationPreference</code> 将主备关系固定，去掉优先级是 2 的数据库。</p><p>对于第三点，使用了一个过滤方法 <code>Get-MailboxDatabaseCopyStatus | Where &#123;$_.status -like &quot;*ount*&quot;&#125;</code> ,<code>ount</code> 是 Active 的数据库可能的四种状态：<code>Mounted</code>、<code>Dismounted</code>、<code>Mounting</code>、<code>Dismounting</code>。</p><h2 id="源码使用方法"><a href="#源码使用方法" class="headerlink" title="源码使用方法"></a>源码使用方法</h2><p>源码我已经放在了 <a href="https://github.com/iarchean/Zabbix/tree/master/ExchangeDatabase">GitHub</a>，使用方法：</p><ol><li>将 <code>Get-ExchangeDBStatus.ps1</code> 加入计划任务，每分钟执行一次</li><li>修改 Exchange 服务器的 <code>Zabbix Agent</code> 服务配置，可以参考 <code>zabbix_agentd.conf</code></li><li>Zabbix 中导入模版 <code>ZabbixTemplate_Exchange Server 2016 Database Monitor.xml</code></li><li>将源码中的另外两个脚本 <code>Get-ExchangeDBDiscovery.ps1</code>、<code>Get-ExchangeDB.ps1</code> 放到与 <code>zabbix_agentd.conf</code> 同级或自定义目录中（放置在自定义目录需要修改 <code>zabbix_agentd.conf</code> 中的脚本路径）</li></ol><p>如果是较大型的企业或数据库服务器较多，推荐将三个 powershell 脚本置于 UNC 路径中，Zabbix 是支持的，这样便于部署配置。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实在早期曾经尝试过在一台机器上进行所有数据库的收集，这样会让整个方案建立起来快速和方便得多，只需要执行一次脚本，也不需要那么多的判断。但是对于 50 个以上数据库规模的架构，这个方法不适用了，一方面脚本执行效率堪忧，完整执行一次可能要 5 分钟以上，这对于我们 99.995% 的 SLA 要求显然是不能够满足需求的；其次 Zabbix 对于单个主机的监控项收集效率也不够，实测起来可能会产生最多 15 分钟的延迟告警，这样是无法接受的。</p><p>如果是小型公司，数据库数量使用单一脚本做全部数据库收集显然是没问题的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在这篇文章里我想要分享一下 Exchange Server 2016 数据库状态以及数据库使用量的监控方法，经过几次修改和迭代，目前我使用的是 Zabbix 3.2 对数据库进行统一、自动化、动态自配置的监控。&lt;/p&gt;</summary>
    
    
    
    <category term="Moniting" scheme="https://archeanz.com/categories/Moniting/"/>
    
    <category term="Exchange" scheme="https://archeanz.com/categories/Moniting/Exchange/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker 学习笔记</title>
    <link href="https://archeanz.com/2019/03/03/docker-learn-memo-1/"/>
    <id>https://archeanz.com/2019/03/03/docker-learn-memo-1/</id>
    <published>2019-03-03T13:10:06.000Z</published>
    <updated>2021-06-30T10:27:15.459Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司的一些服务将要迁移至 Docker 平台，为了能够理解 Docker 原理，决定自己从零开始学习 Docker 这个风靡全球的容器解决方案，将学习的过程记录下来。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Docker-在-CentOS-6-10-上的安装"><a href="#Docker-在-CentOS-6-10-上的安装" class="headerlink" title="Docker 在 CentOS 6.10 上的安装"></a>Docker 在 CentOS 6.10 上的安装</h3><p>公司的系统使用的是 CentOS 6，所以先将内核升级至 3.10 以上版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">yum install https://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm</span><br><span class="line">yum --enablerepo=elrepo-kernel install kernel-lt -y</span><br></pre></td></tr></table></figure><p>之后使用下面的命令将 Docker 源加入到 yum 源中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tee /etc/yum.repos.d/docker.repo &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">[dockerrepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>之后运行下面的命令安装、启动 Docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-engine</span><br><span class="line">service docker start</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="中间遇到很多问题，大概列举一下"><a href="#中间遇到很多问题，大概列举一下" class="headerlink" title="中间遇到很多问题，大概列举一下"></a>中间遇到很多问题，大概列举一下</h3><ul><li>docker: relocation error: docker: symbol dm_task_get_info_with_deferred_remove, version Base not defined in file libdevmapper.so.1.02 with link time reference</li></ul><p>这个是说 <code>device-mapper</code> 版本过低，升级一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update device-mapper</span><br></pre></td></tr></table></figure><ul><li>FATAL: Module bridge not found.</li></ul><p>内核版本问题，升级到 3.10 以上解决</p><ul><li>FATA[0000] Error starting daemon: Error initializing network controller: Error creating default “bridge” network: can’t find an address range for interface “docker0” </li></ul><p>此错误是因为公司内网有 172.16.0.0/16 的路由表，将 docker0 的网卡网段占用了导致的，通过在 <code>/etc/sysconfig/docker</code> 中增加以下参数，强制让 Docker 创建虚拟机时使用特定网段来解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">other_args=&quot;-bip=192.168.100.1/24&quot;</span><br></pre></td></tr></table></figure><ul><li>拉取镜像提示 Get <a href="https://index.docker.io/v1/repositories/library/hello-world/images">https://index.docker.io/v1/repositories/library/hello-world/images</a>: dial tcp 52.207.42.240:443: network is unreachable</li></ul><p>这个肯定是网络问题了，公司的标准服务器是没有办法上外网的，系统环境变量中指定我自己的代理服务器居然也不管用，尝试了多种方法，目前问题还没解决</p><h3 id="Docker-在-Ubuntu-16-04-上的安装"><a href="#Docker-在-Ubuntu-16-04-上的安装" class="headerlink" title="Docker 在 Ubuntu 16.04 上的安装"></a>Docker 在 Ubuntu 16.04 上的安装</h3><p>由于 Docker 最早就是在 Ubuntu 上发展出来的，这里也记录下 Ubuntu 16.04 的安装方法</p><p>首先，安装 Docker 官方仓库的 GPG key 到系统中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>添加 Docker apt 源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure><p>然后，进行一下更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>确认 Docker repo 可以安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache policy docker-ce</span><br></pre></td></tr></table></figure><p>如果看到下面的内容说明是 OK 的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Output of apt-cache policy docker-ce</span><br><span class="line">docker-ce:</span><br><span class="line">  Installed: (none)</span><br><span class="line">  Candidate: 18.06.1~ce~3-0~ubuntu</span><br><span class="line">  Version table:</span><br><span class="line">     18.06.1~ce~3-0~ubuntu 500</span><br><span class="line">        500 https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages</span><br></pre></td></tr></table></figure><p>安装 Docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y docker-ce</span><br></pre></td></tr></table></figure><p>确认 Docker 是否已经安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure><p>类似下面的输出说明正确安装了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Thu 2018-10-18 20:28:23 UTC; 35s ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 13412 (dockerd)</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           ├─13412 /usr/bin/dockerd -H fd://</span><br><span class="line">           └─13421 docker-containerd --config /var/run/docker/containerd/containerd.toml</span><br></pre></td></tr></table></figure><p>另外，docker run 仍然是提示网络问题无法访问，跟 CentOS 一样无论如何加代理都不行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker run hello-world</span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">docker: Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers).</span><br><span class="line">See &#x27;docker run --help&#x27;.</span><br></pre></td></tr></table></figure><p>最后，只能让 Docker Host 直接连接外网来解决这个问题。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="执行-Docker-命令"><a href="#执行-Docker-命令" class="headerlink" title="执行 Docker 命令"></a>执行 Docker 命令</h3><p>开始了解 Docker 命令，最简单的方法就是执行 Hello World 了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br></pre></td></tr></table></figure><p>成功后会看到如下的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="运行一个-Docker-容器"><a href="#运行一个-Docker-容器" class="headerlink" title="运行一个 Docker 容器"></a>运行一个 Docker 容器</h3><p>hello-world 这个镜像的作用是输出一段文本然后退出，每一个 Docker 容器其实都是一个有特定功能的应用，比如 <code>ubuntu</code> 这个镜像，就是一个 Ubuntu 虚拟机。</p><p>试着运行一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -d ubuntu</span><br><span class="line"></span><br><span class="line"># -it 参数可以让我们交互式的 shell 进入容器</span><br></pre></td></tr></table></figure><p>这个时候会输出一段字符串，这段字符串可以理解为 Docker 容器 ID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41b162b9dd3f4dc2b7d37bf195a2c4f09d38a05cf750cfbf07e90313da2a3995</span><br></pre></td></tr></table></figure><p>这个时候，我们就可以进入这个容器内，去一看究竟了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it 41b16 /bin/bash</span><br><span class="line"></span><br><span class="line">root@41b162b9dd3f:/# ps -ef </span><br><span class="line"></span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 07:09 pts/0    00:00:00 /bin/bash</span><br><span class="line">root        10     0  0 07:11 pts/1    00:00:00 /bin/bash</span><br><span class="line">root        21    10  0 07:13 pts/1    00:00:00 ps -ef</span><br></pre></td></tr></table></figure><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>用一段时间的 Docker 之后，我们可能会有很多运行中的和非运行状态的容器，怎么去管理它们呢？</p><h3 id="查看-Docker-容器"><a href="#查看-Docker-容器" class="headerlink" title="查看 Docker 容器"></a>查看 Docker 容器</h3><p>docker ps 命令可以让我们看到目前运行中的 Docker 容器情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">41b162b9dd3f        ubuntu              &quot;/bin/bash&quot;              5 minutes ago       Up 5 minutes                                 zealous_murdock</span><br><span class="line">47651cfa1d8e        golang              &quot;bash&quot;                   14 hours ago        Up 14 hours                                  optimistic_lederberg</span><br><span class="line">3b80522e5902        busybox             &quot;sh&quot;                     37 hours ago        Up 37 hours                                  zealous_darwin</span><br><span class="line">8b881720ceb8        redis               &quot;docker-entrypoint.s…&quot;   37 hours ago        Up 37 hours         0.0.0.0:6379-&gt;6379/tcp   musing_noyce</span><br><span class="line">f3f14f20b61f        nginx               &quot;nginx -g &#x27;daemon of…&quot;   37 hours ago        Up 37 hours         80/tcp                   zealous_blackburn</span><br></pre></td></tr></table></figure><p>奇怪，我们刚才运行的 Hello World 没有在列表里，什么原因呢？</p><p>其实 Hello World 属于非活动状态的镜像，只要给 <code>docker ps</code> 命令加上 <code>-a</code> 参数就可以看到了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                    NAMES</span><br><span class="line">41b162b9dd3f        ubuntu              &quot;/bin/bash&quot;              6 minutes ago       Up 6 minutes                                         zealous_murdock</span><br><span class="line">258796d0e4ed        hello-world         &quot;/hello&quot;                 12 minutes ago      Exited (0) 12 minutes ago                            trusting_swartz</span><br><span class="line">47651cfa1d8e        golang              &quot;bash&quot;                   14 hours ago        Up 14 hours                                          optimistic_lederberg</span><br><span class="line">3b80522e5902        busybox             &quot;sh&quot;                     37 hours ago        Up 37 hours                                          zealous_darwin</span><br><span class="line">8b881720ceb8        redis               &quot;docker-entrypoint.s…&quot;   37 hours ago        Up 37 hours                 0.0.0.0:6379-&gt;6379/tcp   musing_noyce</span><br><span class="line">0a02170a956f        hello-world         &quot;/hello&quot;                 37 hours ago        Exited (0) 37 hours ago                              determined_mestorf</span><br><span class="line">f3f14f20b61f        nginx               &quot;nginx -g &#x27;daemon of…&quot;   37 hours ago        Up 37 hours                 80/tcp                   zealous_blackburn</span><br><span class="line">b43d4f2ba5ed        ubuntu              &quot;/bin/bash&quot;              37 hours ago        Exited (0) 7 minutes ago                             unruffled_snyder</span><br><span class="line">66aa497d9767        ubuntu              &quot;/bin/bash&quot;              37 hours ago        Exited (0) 37 hours ago                              hungry_boyd</span><br><span class="line">126e0f019b19        ubuntu              &quot;/bin/bash&quot;              37 hours ago        Exited (0) 37 hours ago                              competent_goldwasser</span><br><span class="line">600adf161623        ubuntu              &quot;/bin/bash&quot;              37 hours ago        Exited (0) 37 hours ago                              upbeat_thompson</span><br><span class="line">3b5d4380392f        ubuntu              &quot;/bin/bash&quot;              37 hours ago        Exited (0) 37 hours ago                              pedantic_euclid</span><br><span class="line">4fd577a1e8bf        ubuntu              &quot;/bin/bash&quot;              37 hours ago        Exited (0) 37 hours ago                              upbeat_mcnulty</span><br></pre></td></tr></table></figure><p>而如果使用 <code>-l</code> 参数，则可以看到最近创建的 Docker 容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -l</span><br><span class="line"></span><br><span class="line">CONTAINER ID  IMAGE COMMAND CREATED STATUS  PORTS NAMES</span><br><span class="line">41b162b9dd3f  ubuntu  &quot;/bin/bash&quot; 10 minutes ago  Up 10 minutes zealous_murdock</span><br></pre></td></tr></table></figure><h3 id="关闭一个-Docker-容器"><a href="#关闭一个-Docker-容器" class="headerlink" title="关闭一个 Docker 容器"></a>关闭一个 Docker 容器</h3><p>我们在测试过程中运行了很多容器实例了，一些容器不需要再去使用了，</p><p>使用 <code>docker stop</code> 命令可以将活动状态的容器停止运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop 41b162b9dd3f</span><br></pre></td></tr></table></figure><p>不仅可以使用 container ID 指定容器，还可以使用容器别名来操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop zealous_murdock</span><br><span class="line"></span><br><span class="line">zealous_murdock</span><br></pre></td></tr></table></figure><p>停止运行的容器就可以关掉了，这里使用的命令是 <code>docker rm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># docker rm zealous_murdock</span><br><span class="line"></span><br><span class="line">zealous_murdock</span><br></pre></td></tr></table></figure><ul><li>overlay2 代替 auFS 作为新的 Union File System 来使用</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近公司的一些服务将要迁移至 Docker 平台，为了能够理解 Docker 原理，决定自己从零开始学习 Docker 这个风靡全球的容器解决方案，将学习的过程记录下来。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://archeanz.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>试一下 Hexo 新主题：icarus</title>
    <link href="https://archeanz.com/2019/03/02/test-new-theme/"/>
    <id>https://archeanz.com/2019/03/02/test-new-theme/</id>
    <published>2019-03-01T16:50:08.000Z</published>
    <updated>2021-06-30T10:27:15.459Z</updated>
    
    <content type="html"><![CDATA[<p>最近将主题从从切换到 icarus，感觉很不错，新建一篇文章试一下。</p><span id="more"></span><div class="justified-gallery">![](https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/fsnwm.jpg)![](https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/xeb0z.jpg)![](https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/535pb.jpg)![](https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/scpg2.jpg)![](https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/p3xdr.jpg)![](https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/7opzs.jpg)</div>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近将主题从从切换到 icarus，感觉很不错，新建一篇文章试一下。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>用Linux做路由器</title>
    <link href="https://archeanz.com/2014/02/07/NAT-on-linux/"/>
    <id>https://archeanz.com/2014/02/07/NAT-on-linux/</id>
    <published>2014-02-07T09:25:39.000Z</published>
    <updated>2021-06-30T10:27:15.459Z</updated>
    
    <content type="html"><![CDATA[<p>今日完成了一个专线项目, 根据集团要求, 需要使用 NAT 的方式联通两个办公区之间的内部网络, 使得可以互相访问服务器资源, 并且保存3个月的 NAT 日志, 出问题可以快速定位到人.</p><p>由于我们办公区没有路由器设备, 于是采用 Linux 服务器做 iptables 转发来实现 NAT 功能, 并且 iptables 可以记录日志; 此项目设计的客户端和服务器不足百台, 不会有太高的并发访问, 一台中等配置的 Linux 服务器完全可以满足要求. </p><span id="more"></span><h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/3uqg1.png" alt="拓扑"></p><!--more--><p><em>我负责的区域在左侧.</em></p><ul><li>办公区和总部通过一条 20M 的 MSTP 线路相连, 互联网段是<code>172.17.176.48/29</code>.</li><li>在办公区<code>10.250.0.0/16</code>可以通过 SNAT 方式访问总部网络<code>10.44.0.0/16</code>, 源 IP 需要 NAT 为<code>172.17.176.50/29</code></li><li>在总部可以通过访问互联地址<code>172.17.176.51/29</code>访问办公区的数据库服务器<code>10.250.8.241</code></li></ul><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>首先在我们<code>10.250.0.0/16</code>这个三层交换机上增加<code>10.44.0.0/16</code>的路由:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route-static 10.44.0.0 255.255.0.0 10.250.254.251</span><br></pre></td></tr></table></figure><p>若要实现双向的 NAT, 还有一个必要条件是一台最小化安装的 Linux 服务器, 最少配置2个网卡, 在此场景下, 网卡配置为: </p><ul><li>eth0作为内部网卡, IP 地址是<code>10.250.254.251</code>; </li><li>eth1作为互联网卡, IP 地址是<code>172.17.176.50</code>;</li><li>eth1对端的 IP 为<code>172.17.176.49</code>.</li></ul><p>服务器的路由配置, 需要能够访问办公区正常的网络资源, 同时将10.44.0.0/16路由至互联网卡:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># netstat -nr</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">172.17.176.48   0.0.0.0         255.255.255.248 U         0 0          0 eth1</span><br><span class="line">10.250.254.0    0.0.0.0         255.255.255.0   U         0 0          0 eth0</span><br><span class="line">10.44.0.0       172.17.176.49   255.255.0.0     UG        0 0          0 eth1</span><br><span class="line">10.250.0.0      10.250.254.254  255.0.0.0       UG        0 0          0 eth0</span><br></pre></td></tr></table></figure><p>开启Linux 内核的转发功能, 编辑<code>/etc/sysctl.conf</code>, 加入如下语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure><h2 id="访问总部网络资源"><a href="#访问总部网络资源" class="headerlink" title="访问总部网络资源"></a>访问总部网络资源</h2><p>此步骤涉及到 SNAT 的概念.</p><p>所谓 SNAT, 即将一段 IP 包的源地址改变, 由于总部的 ACL 策略中仅允许<code>172.17.176.48/29</code>网段访问, 所以我们访问总部时就必须将源地址 NAT 为上述网段.</p><p>iptables 的 nat tables 有3个内置的 chain, 分别是<code>PREROUTING</code>, <code>POSTROUTING</code>和<code>OUTPUT</code>chain</p><blockquote><p>PREROUTING chain – Alters packets before routing. i.e Packet translation happens immediately after the packet comes to the system (and before routing). This helps to translate the destination ip address of the packets to something that matches the routing on the local server. This is used for DNAT (destination NAT).<br>POSTROUTING chain – Alters packets after routing. i.e Packet translation happens when the packets are leaving the system. This helps to translate the source ip address of the packets to something that might match the routing on the desintation server. This is used for SNAT (source NAT).<br>OUTPUT chain – NAT for locally generated packets on the firewall.</p></blockquote><p>我们需要使用的是<code>POSTROUTING</code> chain.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># iptables -A POSTROUTING -s 10.250.0.0/16 -o eth1 -j SNAT --to-source 172.17.176.50</span><br></pre></td></tr></table></figure><p>解释一下, 就是将来自<code>10.250.0.0/16</code>网段的包, 由 eth1 网口出去时的源 IP 变更为<code>172.17.176.50</code>; 我们之前已经将路由配置为访问10.44网段时都走 eth1, 所以此行解决了访问总部的问题.</p><p>如果查看, 可以看到此条目已经生效:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># iptables -L -t nat</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">NAT        all  --  10.250.0.0/16        0.0.0.0/0           to:172.17.176.50</span><br></pre></td></tr></table></figure><p>检查生效后可以使用<code>/etc/init.d/iptables save</code> 将此条保存到<code>/etc/sysconfig/iptables </code>中, 这样重启iptables 后也不会丢是配置.</p><h2 id="总部访问办公区服务器"><a href="#总部访问办公区服务器" class="headerlink" title="总部访问办公区服务器"></a>总部访问办公区服务器</h2><p>此步骤不仅涉及 SNAT, 还涉及到了 DNAT 的概念.</p><p>DNAT 即将一段 IP 包的目的地址改变. 此方式</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今日完成了一个专线项目, 根据集团要求, 需要使用 NAT 的方式联通两个办公区之间的内部网络, 使得可以互相访问服务器资源, 并且保存3个月的 NAT 日志, 出问题可以快速定位到人.&lt;/p&gt;
&lt;p&gt;由于我们办公区没有路由器设备, 于是采用 Linux 服务器做 iptables 转发来实现 NAT 功能, 并且 iptables 可以记录日志; 此项目设计的客户端和服务器不足百台, 不会有太高的并发访问, 一台中等配置的 Linux 服务器完全可以满足要求. &lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://archeanz.com/categories/linux/"/>
    
    <category term="iptables" scheme="https://archeanz.com/categories/linux/iptables/"/>
    
    
  </entry>
  
  <entry>
    <title>Secure Proxy Service</title>
    <link href="https://archeanz.com/2014/01/23/secure-proxy-service/"/>
    <id>https://archeanz.com/2014/01/23/secure-proxy-service/</id>
    <published>2014-01-23T03:32:15.000Z</published>
    <updated>2021-06-30T10:27:15.459Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-免责声明"><a href="#0-免责声明" class="headerlink" title="0. 免责声明"></a><code>0.</code> 免责声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此服务仅用于研究互联网技术, 使用者访问了任何网站或发表了任何言论, 不代表本人支持其观点. </span><br></pre></td></tr></table></figure><h3 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a><code>1.</code> 描述</h3><p>这是一个”加密的” socks 代理服务, 使用者能够安全的访问世界上任何一个网站, 在本地网络状况正常的情况下, 可以:</p><h4 id="流畅的播放-YouTube-720P-视频-基本流畅的播放-1080P-视频"><a href="#流畅的播放-YouTube-720P-视频-基本流畅的播放-1080P-视频" class="headerlink" title="流畅的播放 YouTube 720P 视频, 基本流畅的播放 1080P 视频:"></a>流畅的播放 YouTube 720P 视频, 基本流畅的播放 1080P 视频:</h4><span id="more"></span><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/umojm.png" alt="720p"></p><h4 id="访问-Facebook-Twitter-Instagram-等网站"><a href="#访问-Facebook-Twitter-Instagram-等网站" class="headerlink" title="访问 Facebook, Twitter, Instagram 等网站."></a>访问 Facebook, Twitter, Instagram 等网站.</h4><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/n5885.png" alt="Instagram"></p><h4 id="为一些-app-提供访问支持"><a href="#为一些-app-提供访问支持" class="headerlink" title="为一些 app 提供访问支持."></a>为一些 app 提供访问支持.</h4><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/gsvzm.png" alt="Terminal"></p><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/xd5u8.png" alt="Github"></p><!--more--><h3 id="2-如何使用"><a href="#2-如何使用" class="headerlink" title="2. 如何使用"></a><code>2.</code> 如何使用</h3><p>我会将<code>服务 IP/端口</code>(全局代理方式)和 <code>PAC URL</code>(Proxy Auto Config 方式) 以邮件形式发送到你的私人邮箱中, 获取到之后, 分别按照如下说明使用:</p><h4 id="全局代理"><a href="#全局代理" class="headerlink" title="全局代理"></a>全局代理</h4><p>在 IE 的 Lan 代理设置, Chrome 的 <a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif">SwitchyOmega</a> 插件, 或 mac 的网络代理配置中填写服务 IP 及端口, 正确操作后, <code>所有 http 服务都将走代理访问</code>, 会导致部分网站访问速度变慢.</p><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/iiais.png" alt="IE.Global"></p><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/c1box.png" alt="Chrome.Global"></p><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/vi70h.png" alt="MAC.Global"></p><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/u4ofp.png" alt="iPhone.Global"></p><h4 id="Proxy-Auto-Config-文件"><a href="#Proxy-Auto-Config-文件" class="headerlink" title="Proxy Auto Config 文件"></a>Proxy Auto Config 文件</h4><p>在 IE 的 Lan 代理设置, Chrome 的 <a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif">SwitchyOmega</a> 插件, 或 mac 的网络代理配置中填写 pac 文件位置, 正确操作后, pac <a href="http://jump.archean.me/pac.html">白名单中的 http 服务</a>将走代理访问, 推荐方式.</p><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/shhu1.png" alt="IE.PAC"></p><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/d14kg.png" alt="Chrome.PAC"></p><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/10ify.png" alt="MAC.PAC"></p><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/dms4c.png" alt="iPhone.PAC"></p><h3 id="3-现存问题"><a href="#3-现存问题" class="headerlink" title="3. 现存问题"></a><code>3.</code> 现存问题</h3><h4 id="网络状况"><a href="#网络状况" class="headerlink" title="网络状况"></a>网络状况</h4><p>众所周知中国几个跨洋光缆不是那么稳定, 代理服务有时会出现网络波动及不可用(非常少, 4年中大概总计1天)的问题, 我这里有几个不同的国外服务器, 在出现异常情况时会及时切换.</p><h4 id="端口被复用"><a href="#端口被复用" class="headerlink" title="端口被复用"></a>端口被复用</h4><p>提供给你的服务端口或 PAC 文件是<code>完全开放</code>的, 意味着一旦泄露, 别人可以直接拿来用, 所以强烈建议不要与其他人共享.</p><p>关于此事, 我正研究不影响用户体验的验证方式, 后续将会改版.</p><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>虽然我保证不会这么做, 且也没什么必要, 但我是有技术手段监听你所有流量的, 请在确保不会提交隐私信息的情况下使用.</p><h3 id="4-费用"><a href="#4-费用" class="headerlink" title="4. 费用"></a><code>4.</code> 费用</h3><p>费用是10元/月, 或100元/年, 接受 Alipay 或 PayPal 转账, 帐号均为 <a href="mailto:&#x7a;&#101;&#112;&#x68;&#x79;&#x72;&#52;&#50;&#50;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;">&#x7a;&#101;&#112;&#x68;&#x79;&#x72;&#52;&#50;&#50;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;</a>.</p><p>如果服务由于不可抗力中断, 我会退给你剩余时间的费用.</p><h3 id="5-一些解释"><a href="#5-一些解释" class="headerlink" title="5. 一些解释"></a><code>5.</code> 一些解释</h3><p><code>加密的</code>: 在国内-&gt;国外这个阶段的所有流量会经过我的加密, 不会遭遇政府的窃取.</p><p><code>访问速度</code>: 与使用人数, 本地网络状况及国际线路有关, 我会尽可能确保稳定.</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;0-免责声明&quot;&gt;&lt;a href=&quot;#0-免责声明&quot; class=&quot;headerlink&quot; title=&quot;0. 免责声明&quot;&gt;&lt;/a&gt;&lt;code&gt;0.&lt;/code&gt; 免责声明&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;此服务仅用于研究互联网技术, 使用者访问了任何网站或发表了任何言论, 不代表本人支持其观点. &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;1-描述&quot;&gt;&lt;a href=&quot;#1-描述&quot; class=&quot;headerlink&quot; title=&quot;1. 描述&quot;&gt;&lt;/a&gt;&lt;code&gt;1.&lt;/code&gt; 描述&lt;/h3&gt;&lt;p&gt;这是一个”加密的” socks 代理服务, 使用者能够安全的访问世界上任何一个网站, 在本地网络状况正常的情况下, 可以:&lt;/p&gt;
&lt;h4 id=&quot;流畅的播放-YouTube-720P-视频-基本流畅的播放-1080P-视频&quot;&gt;&lt;a href=&quot;#流畅的播放-YouTube-720P-视频-基本流畅的播放-1080P-视频&quot; class=&quot;headerlink&quot; title=&quot;流畅的播放 YouTube 720P 视频, 基本流畅的播放 1080P 视频:&quot;&gt;&lt;/a&gt;流畅的播放 YouTube 720P 视频, 基本流畅的播放 1080P 视频:&lt;/h4&gt;</summary>
    
    
    
    <category term="Web" scheme="https://archeanz.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx禁止其他域名访问</title>
    <link href="https://archeanz.com/2013/10/24/nginx-deny-other-domain-access/"/>
    <id>https://archeanz.com/2013/10/24/nginx-deny-other-domain-access/</id>
    <published>2013-10-24T04:09:50.000Z</published>
    <updated>2021-06-30T10:27:15.459Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到一则来自<a href="http://vtp.me/">@kyaky</a>的评论</p><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/dutd9.png"></p><p>让我也意识到了这个问题:</p><p>如果别人把我的IP地址绑到他的域名上, 那我就是在为别人搭博客了. 我本以为Nginx配置中的<code>server_name</code>选项可以进行阻挡, 看来不实践真的是不能轻易下结论.</p><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/ij1iv.png"></p><p>今天就回顾一下这个问题的所在, 及解决方案. </p><span id="more"></span><p>DNS解析场景是这样:</p><pre><code>域名    类型    IPA.com    A    a.b.c.dB.com    A    a.b.c.d</code></pre><p>现在我的网站配置的默认服务是<code>A.com.conf</code>:</p><pre><code>server &#123;    listen 80 default;    server_name A.com;&#125;</code></pre><p>当初我为了避免直接拿IP访问站点, 做了IP的过滤:</p><pre><code>if ( $host ~* &quot;\d+\.\d+\.\d+\.\d+&quot; ) &#123;    return 403;&#125;</code></pre><p>在这种情况下, 访问<code>A.com</code>会找到<code>a.b.c.d</code>这个IP, Nginx解析得知匹配到了<code>A.com.conf</code>, 于是进入document root目录进行服务.</p><p>当访问<code>B.com</code>时, DNS也会找到<code>a.b.c.d</code>这个IP, Nginx解析得知没有匹配, 于是也会进入<code>A.com.conf</code>的document root, 继续提供服务 – 因为是<code>default</code>.</p><p>当时忽略了域名绑定IP的问题, 那么我再加一条<code>if&#123;&#125;</code>判断, 不符合<code>archean.me</code>的都返回403, 即可解决这个问题了.</p><hr><p>但这样做显然不够优雅, 不仅陡然增加了Nginx配置文件的复杂度, 同时如果有多个域名绑定这台机器, 需要修改的地方就太多了.</p><p>所以查阅Nginx官方资料, 果然有相应的<a href="http://wiki.nginx.org/NginxVirtualHostExample">解决办法</a></p><p>原来我没有做默认服务<code>default.conf</code>的配置, <code>A Default &quot;Catch All&quot; Server Block</code></p><pre><code>server &#123;    listen 80 default_server;    server_name _; # This is just an invalid value which will never trigger on a real hostname.    return 403;&#125;</code></pre><p>关键在于<code>server_name _;</code>, 这是指无效域名, 无论是IP地址, 错误的域名拼写或是未在其他虚拟主机配置中提到的域名, 均会触发<code>return 403;</code>, 显示页面不存在.</p><p>于是略加改进, 去掉其他虚拟主机中的default字段; 把<code>default.conf</code>中的<code>return 403;</code>改为重定向到我们期望的默认首页, 即可解决我们的问题.</p><pre><code>server &#123;    listen 80 default_server;    server_name _;    rewrite ^ http://archean.me$request_uri?;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天看到一则来自&lt;a href=&quot;http://vtp.me/&quot;&gt;@kyaky&lt;/a&gt;的评论&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/dutd9.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;让我也意识到了这个问题:&lt;/p&gt;
&lt;p&gt;如果别人把我的IP地址绑到他的域名上, 那我就是在为别人搭博客了. 我本以为Nginx配置中的&lt;code&gt;server_name&lt;/code&gt;选项可以进行阻挡, 看来不实践真的是不能轻易下结论.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/ij1iv.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天就回顾一下这个问题的所在, 及解决方案. &lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="https://archeanz.com/categories/nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>用 Dropbox public folder 做博客的超稳定图床</title>
    <link href="https://archeanz.com/2013/10/21/make-dropbox-public-folder-a-stable-pic-server/"/>
    <id>https://archeanz.com/2013/10/21/make-dropbox-public-folder-a-stable-pic-server/</id>
    <published>2013-10-21T14:52:35.000Z</published>
    <updated>2021-06-30T10:27:15.459Z</updated>
    
    <content type="html"><![CDATA[<p>由于 Dropbox 修改了 Public Folder 的功能，方法已失效。</p><p>这个Blog是搭建在<a href="https://www.digitalocean.com/?refcode=87b0301d5ece">Digital Ocean</a>上的, 这个VPS还是很不错的, 加州的节点在天朝访问速度非常可以, 拥有20G SSD磁盘和每月1T的流量, 只需5$, 还是非常超值的.</p><p>但是即便如此, Blog需要的大量图片等元素还是非常占用空间的, 所以只好想办法寻找一个稳定的图床来存. 我一直是Dropbox的重度用户, 自然想到她的Public Folder. </p><blockquote><p>Dropbox Public目录每日限制流量 20G, <a href="https://www.dropbox.com/help/45/en">来源</a></p></blockquote><span id="more"></span><p>Dropbox Public Folder的地址是<code>https://dl.dropboxusercontent/u/idxxxxxxxx/</code>, Blog引用起来不够优雅, 于是萌生了此文.</p><p>配置起来非常简单, 经过我的反复实践, Nginx vhost最小配置为:</p><pre><code>server &#123;     listen 80;    server_name img.archean.me;    root /path/to/www/root; #也可省略        location / &#123;        rewrite /(.*) /u/DropboxID/img/$1 break;        proxy_pass https://dl.dropboxusercontent.com/;    &#125;&#125;</code></pre><p>此配置足以使用, 最终效果是当我访问<code>http://img.archean.me/1.jpg</code>时, 可以显示<code>https://dl.dropboxusercontent.com/u/19060928/img/1.jpg</code>的图片</p><p><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/957z1.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于 Dropbox 修改了 Public Folder 的功能，方法已失效。&lt;/p&gt;
&lt;p&gt;这个Blog是搭建在&lt;a href=&quot;https://www.digitalocean.com/?refcode=87b0301d5ece&quot;&gt;Digital Ocean&lt;/a&gt;上的, 这个VPS还是很不错的, 加州的节点在天朝访问速度非常可以, 拥有20G SSD磁盘和每月1T的流量, 只需5$, 还是非常超值的.&lt;/p&gt;
&lt;p&gt;但是即便如此, Blog需要的大量图片等元素还是非常占用空间的, 所以只好想办法寻找一个稳定的图床来存. 我一直是Dropbox的重度用户, 自然想到她的Public Folder. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dropbox Public目录每日限制流量 20G, &lt;a href=&quot;https://www.dropbox.com/help/45/en&quot;&gt;来源&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用一台Raspberry Pi作为家庭网关, 无障碍翻墙</title>
    <link href="https://archeanz.com/2013/10/16/breaking-gfw-with-raspberry-pi/"/>
    <id>https://archeanz.com/2013/10/16/breaking-gfw-with-raspberry-pi/</id>
    <published>2013-10-16T12:57:37.000Z</published>
    <updated>2021-06-30T10:27:15.459Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Arthor:    Archean Zhang</p><p>Email:    <a href="mailto:&#122;&#101;&#x70;&#104;&#121;&#x72;&#52;&#x32;&#50;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;">&#122;&#101;&#x70;&#104;&#121;&#x72;&#52;&#x32;&#50;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;</a></p><p>Version:    1.0.1</p><p>Date:        2013/8/16</p></blockquote><p>长期被GFW困扰, 我终于忍不住动手了: 把家里的Raspberry Pi和与自由世界的主机建立OpenVPN over Stunnel的链路, 根据大中华3000条路由来匹配, 国外网站自动走OpenVPN出去以实现翻墙.</p><p>以下文章是基于一台Linux服务器(CentOS 6.4)撰写的, 将下面<code>Router</code>的换成Raspberry Pi也一样.</p><span id="more"></span><h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.    准备"></a><code>1</code>.    准备</h2><p>硬件:</p><ul><li>   1台位于自由世界的Linux服务器 (Server)</li><li>   1台位于本地的Linux服务器 (Router)</li><li>   客户端 (Client)</li></ul><p>软件:</p><ul><li>   Stunnel</li><li>   OpenVPN</li><li>   DNSMasq</li></ul><p>拓扑图:<br><img src="https://archean-1256172257.cos.ap-beijing.myqcloud.com/blog/sml2k.png" alt="Topology"></p><h2 id="2-Server端配置"><a href="#2-Server端配置" class="headerlink" title="2.    Server端配置"></a><code>2</code>.    Server端配置</h2><p>安装好Linux系统后(Red hat或CentOS), 同步服务器时间(非常重要):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ntpdate time.nist.gov</span><br></pre></td></tr></table></figure><h3 id="2-1-OpenVPN"><a href="#2-1-OpenVPN" class="headerlink" title="2.1    OpenVPN"></a><code>2.1</code>    OpenVPN</h3><p>下载安装OpenVPN, 生成服务器端证书, OpenVPN依赖lzo, 需要一同安装:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># yum install lzo openvpn</span><br></pre></td></tr></table></figure><p>服务器端配置文件<code>/etc/openvpn/server.conf</code>, 范例及说明如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">local 127.0.0.1 #监听本地接口</span><br><span class="line">port 4443 #监听端口</span><br><span class="line">proto tcp #协议</span><br><span class="line">dev tap</span><br><span class="line">ca /etc/openvpn/keys/ca.crt#证书</span><br><span class="line">cert /etc/openvpn/keys/server.crt#证书</span><br><span class="line">dh /etc/openvpn/keys/dh1024.pem#证书</span><br><span class="line">server 172.31.189.0 255.255.255.0#网段</span><br><span class="line">client-to-client</span><br><span class="line">duplicate-cn</span><br><span class="line">keepalive 10 120</span><br><span class="line">comp-lzo</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">status openvpn-status.log#状态日志</span><br><span class="line">log-append  openvpn.log#执行日志</span><br><span class="line">verb 3</span><br></pre></td></tr></table></figure><p>启动openvpn:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># openvpn --config /etc/openvpn/server.conf --deamon</span><br></pre></td></tr></table></figure><p>观察日志, 如果出现<code>“Initialization Sequence Completed”</code>则代表启动成功.</p><h3 id="2-2-Stunnel"><a href="#2-2-Stunnel" class="headerlink" title="2.2    Stunnel"></a><code>2.2</code>    Stunnel</h3><p>Openvpn的Server端只监控本地接口, 就是为了用Stunnel将流量加密, 在Local端安全的链接, 达到加密, 混淆流量的作用, 以绕开GFW的监控.</p><p>下载安装stunnel</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># yum install stunnel</span><br></pre></td></tr></table></figure><p>安装过程中会生成服务器证书<code>stunnel.pem</code>, 按照提示来即可.</p><p>编辑配置文件<code>/usr/bin/etc/stunnel.conf</code>, 如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cert = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">CAfile = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">socket = l:TCP_NODELAY=1</span><br><span class="line">socket = r:TCP_NODELAY=1</span><br><span class="line"></span><br><span class="line">pid = /tmp/stunnel.pid</span><br><span class="line">verify = 3</span><br><span class="line"></span><br><span class="line">setuid = stunnel</span><br><span class="line">setgid = stunnel</span><br><span class="line"></span><br><span class="line">compression = zlib</span><br><span class="line">delay = no</span><br><span class="line">sslVersion = TLSv1</span><br><span class="line">fips=no</span><br><span class="line"></span><br><span class="line">debug = 7</span><br><span class="line">syslog = no</span><br><span class="line">output = /usr/local/etc/stunnel/stunnel.log</span><br><span class="line"></span><br><span class="line">[s-openvpn]</span><br><span class="line">accept = 13579#监听端口</span><br><span class="line">connect = 127.0.0.1:4443#OpenVPN端口</span><br></pre></td></tr></table></figure><p>启动stunnel:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># stunnel</span><br></pre></td></tr></table></figure><p>查看OpenVPN和Stunnel是否正确执行, 检查相应端口:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># netstat -ntwla</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State      </span><br><span class="line">tcp        0      0 0.0.0.0:13579               0.0.0.0:*                   LISTEN    </span><br><span class="line">tcp        0      0 127.0.0.1:4443              127.0.0.1:50223             ESTABLISHED </span><br><span class="line"># lsof -i:4443 -n</span><br><span class="line">COMMAND   PID    USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME</span><br><span class="line">openvpn 25290    root    5u  IPv4 2982393      0t0  TCP *:pharos (LISTEN)</span><br><span class="line">openvpn 25290    root    8u  IPv4 3361561      0t0  TCP 127.0.0.1:pharos-&gt;127.0.0.1:50223 (ESTABLISHED)</span><br><span class="line">stunnel 26801 stunnel   10u  IPv4 3361560      0t0  TCP 127.0.0.1:50223-&gt;127.0.0.1:pharos (ESTABLISHED)</span><br></pre></td></tr></table></figure><p><strong>看到端口均已正确监听, 至此Server端配置完成</strong></p><h2 id="3-Router配置"><a href="#3-Router配置" class="headerlink" title="3.    Router配置"></a><code>3</code>.    Router配置</h2><p>安装好Linux系统后(Red hat或CentOS), 同步服务器时间(非常重要):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># ntpdate time.nist.gov</span><br></pre></td></tr></table></figure><h3 id="3-1-安装Stunnel"><a href="#3-1-安装Stunnel" class="headerlink" title="3.1    安装Stunnel"></a><code>3.1</code>    安装Stunnel</h3><p>Router端需要首先安装Stunnel, 在本地开启加密链路, 透传OpenVPN加密端口4443, 然后OpenVPN才能开始接入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install stunnel</span><br></pre></td></tr></table></figure><p>将Server端Stunnel证书传过来, 以便验证:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># scp root@server:/usr/local/etc/stunnel.pem root@router:/usr/local/etc/stunnel.pem</span><br></pre></td></tr></table></figure><p>开始进行stunnel配置, 配置文件<code>/usr/local/etc/stunnel.conf</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pid = /tmp/stunnel.pid</span><br><span class="line">cert = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">socket = l:TCP_NODELAY=1</span><br><span class="line">socket = r:TCP_NODELAY=1</span><br><span class="line">verify = 3</span><br><span class="line">CAfile = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">client=yes</span><br><span class="line">compression = zlib</span><br><span class="line">ciphers = AES256-SHA</span><br><span class="line">delay = no</span><br><span class="line">failover = prio</span><br><span class="line">sslVersion = TLSv1</span><br><span class="line"></span><br><span class="line">output = /root/bin/logs/stunnel.log</span><br><span class="line">[s-openvpn]</span><br><span class="line">accept = 127.0.0.1:4443</span><br><span class="line">connect = server.ip.address:13579</span><br></pre></td></tr></table></figure><p>启动stunnel:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># stunnel</span><br></pre></td></tr></table></figure><h3 id="3-2-安装OpenVPN"><a href="#3-2-安装OpenVPN" class="headerlink" title="3.2    安装OpenVPN"></a><code>3.2</code>    安装OpenVPN</h3><p>下载安装OpenVPN, OpenVPN依赖lzo, 需要一同安装:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install lzo openvpn</span><br></pre></td></tr></table></figure><p>配置Router端配置文件<code>/etc/openvpn/hk.ovpn</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dev tap#设备模式</span><br><span class="line">port 65530#本地监听端口</span><br><span class="line">proto tcp#协议</span><br><span class="line">client#服务模式:client</span><br><span class="line">tls-client#加密客户端</span><br><span class="line">ns-cert-type server</span><br><span class="line">remote 127.0.0.1 4443#Server端口, 由于使用Stunnel加密透传, 所以连接本地端口</span><br><span class="line">ca /etc/openvpn/ca/ca.crt#证书</span><br><span class="line">key /etc/openvpn/ca/client1.key#证书</span><br><span class="line">cert /etc/openvpn/ca/client1.crt#证书</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">#route-method exe</span><br><span class="line">#route-delay 2</span><br><span class="line">comp-lzo</span><br><span class="line">status /etc/openvpn/openvpn-status.log#状态日志</span><br><span class="line">log-append  /etc/openvpn/ca.log#执行日志</span><br><span class="line">verb 3</span><br></pre></td></tr></table></figure><p>启动OpenVPN:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># openvpn --daemon --config /etc/openvpn/hk.ovpn</span><br></pre></td></tr></table></figure><p>观察日志, 如果出现<code>“Initialization Sequence Completed”</code>则代表启动成功.</p><p>检查隧道:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ip addr</span><br><span class="line">11: tap0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN qlen 100</span><br><span class="line">    link/ether 06:10:50:e5:e5:2c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.31.188.2/24 brd 172.31.188.255 scope global tap0</span><br><span class="line">    inet6 fe80::410:50ff:fee5:e52c/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">       # ping 172.31.188.1</span><br><span class="line">PING 172.31.188.1 (172.31.188.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.31.188.1: icmp_seq=1 ttl=64 time=67.3 ms</span><br><span class="line">64 bytes from 172.31.188.1: icmp_seq=2 ttl=64 time=67.1 ms</span><br><span class="line">^C</span><br><span class="line">--- 172.31.188.1 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1588ms</span><br><span class="line">rtt min/avg/max/mdev = 67.183/67.284/67.386/0.278 ms</span><br></pre></td></tr></table></figure><p>链路通畅</p><h3 id="3-3-安装DNSmasq"><a href="#3-3-安装DNSmasq" class="headerlink" title="3.3    安装DNSmasq"></a><code>3.3</code>    安装DNSmasq</h3><p>Router若要进行翻墙, 需要使用国外DNS, 而浏览国内网站时, 如果使用国外DNS, 会造成将访问导向国外站点, 造成访问速度变慢, 所以此方案使用DNSmasq解决此问题.</p><p>同时DNSmasq也是一个轻量级DHCP服务器, 非常方便好用.</p><p>安装DNSmasq:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install dnsmasq</span><br></pre></td></tr></table></figure><p>编辑DNSmasq配置文件<code>/etc/dnsmasq.conf</code>, 假设Router本地IP是10.2.166.10, 本地分发网段是10.2.166.0/24, 则配置如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># DHCP config</span><br><span class="line">expand-hosts</span><br><span class="line">domain=archean.me</span><br><span class="line"># DHCP Range</span><br><span class="line">dhcp-range=10.2.166.50,10.2.166.150,12h#DHCP地址池</span><br><span class="line"># DHCP route</span><br><span class="line">dhcp-option=3,10.2.166.10#路由</span><br><span class="line"># Apple ntp server</span><br><span class="line">dhcp-option=option:ntp-server,10.3.1.233#ntp时间服务器</span><br><span class="line"></span><br><span class="line"># DNS server</span><br><span class="line">no-resolv</span><br><span class="line">no-poll</span><br><span class="line">server=8.8.8.8</span><br><span class="line">server=8.8.4.4</span><br><span class="line">conf-dir=/etc/dnsmasq.d</span><br><span class="line"></span><br><span class="line"># AppleTV trailers</span><br><span class="line">address=/trailers.apple.com/180.153.225.136</span><br><span class="line"></span><br><span class="line"># Static IPs</span><br><span class="line"># dhcp-host=xx:xx:xx:xx:xx:xx,10.2.166.121</span><br></pre></td></tr></table></figure><p>配置分类解析配置文件<code>/etc/dnsmasq.d/china.conf</code>, 以使常用域名走国内DNS解析, 举例如下, 根据自身情况更改:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># server=/domain.name/dns.server</span><br><span class="line">server=/115.com/114.114.114.114</span><br><span class="line">server=/123u.com/114.114.114.114</span><br><span class="line">server=/126.com/114.114.114.114</span><br><span class="line">server=/126.net/114.114.114.114</span><br><span class="line">server=/163.com/114.114.114.114</span><br><span class="line">server=/17173.com/114.114.114.114</span><br><span class="line">server=/17cdn.com/114.114.114.114</span><br><span class="line">server=/51.la/114.114.114.114</span><br><span class="line">server=/6rooms.com/114.114.114.114</span><br><span class="line">server=/91.com/114.114.114.114</span><br></pre></td></tr></table></figure><p><strong>至此准备工作完成, 可以启动路由器了</strong></p><h3 id="3-4-启动路由器"><a href="#3-4-启动路由器" class="headerlink" title="3.4    启动路由器"></a><code>3.4</code>    启动路由器</h3><p><strong>思路</strong></p><p>默认路由为OpenVPN Server端私网IP, chnroute生成的<a href="http://www.lailai-start.com/CN">3000条国内路由</a>走国内链路, 以达到分流/翻墙的目的.</p><p><strong>步骤:</strong></p><ul><li>   启动Stunnel, 启动DNSmasq</li><li>   开启linux内核转发功能</li><li>   启动OpenVPN</li><li>   增加3000条国内路由(<a href="http://www.lailai-start.com/CN">点这里下载</a>)</li><li>   增加默认路由, 增加下一跳为OpenVPN Server端私网IP</li></ul><p>将步骤编写成脚本, 如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Stunnel up</span><br><span class="line">/usr/bin/stunnel</span><br><span class="line">/usr/sbin/dnsmasq</span><br><span class="line"></span><br><span class="line"># date ntp time</span><br><span class="line">ntpdate ntp.server.name</span><br><span class="line">/sbin/route add -net 10.0.0.0/8 gw 10.2.166.1</span><br><span class="line">/sbin/route add -host server.ip.address gw 10.2.166.1</span><br><span class="line"></span><br><span class="line"># iptables NAT</span><br><span class="line">/sbin/iptables -t nat -A POSTROUTING -o tap0 -j MASQUERADE</span><br><span class="line">sysctl -w net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line"># start Openvpn</span><br><span class="line">killall openvpn</span><br><span class="line">/usr/local/sbin/openvpn --daemon --config /etc/openvpn/hk.ovpn</span><br><span class="line">sleep 5</span><br><span class="line"># Chnrouters</span><br><span class="line">for i in `cat /root/bin/CN` ; do /sbin/route add -net $i gw 10.2.166.1 ; done</span><br><span class="line">/sbin/route del default</span><br><span class="line">/sbin/route add default gw 10.2.166.1</span><br><span class="line">/sbin/route add default gw 172.31.188.1</span><br></pre></td></tr></table></figure><p>启动脚本, Router环境搭建完成, 国外网络访问测试:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># tracert 8.8.8.8</span><br><span class="line">traceroute to 8.8.8.8 (8.8.8.8), 30 hops max, 60 byte packets</span><br><span class="line"> 1  172.31.188.1 (172.31.188.1)  68.963 ms  68.913 ms  68.914 ms</span><br><span class="line"> 2  103.30.4.1 (103.30.4.1)  109.650 ms  109.651 ms  109.645 ms</span><br><span class="line"> 3  172.16.0.2 (172.16.0.2)  109.410 ms  109.454 ms  109.448 ms</span><br><span class="line"> 4  gi1-26.br02.hkg04.pccwbtn.net (63.218.241.1)  109.384 ms  109.384 ms  109.465 ms</span><br><span class="line"> 5  72.14.196.197 (72.14.196.197)  109.415 ms  109.381 ms  109.344 ms</span><br><span class="line"> 6  209.85.241.56 (209.85.241.56)  109.368 ms 209.85.241.58 (209.85.241.58)  105.488 ms  149.385 ms</span><br><span class="line"> 7  216.239.43.17 (216.239.43.17)  108.792 ms  68.841 ms 209.85.253.69 (209.85.253.69)  69.430 ms</span><br><span class="line"> 8  * * *</span><br><span class="line"> 9  google-public-dns-a.google.com (8.8.8.8)  108.102 ms  107.936 ms  107.819 ms</span><br></pre></td></tr></table></figure><p>可以看到直接走OpenVPN私网IP出去, 国内网络访问测试:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># traceroute www.baidu.com</span><br><span class="line">traceroute to www.baidu.com (115.239.210.26), 30 hops max, 60 byte packets</span><br><span class="line"> 1  10.2.166.1 (10.2.166.1)  2.267 ms  2.470 ms  2.623 ms</span><br><span class="line"> 2  10.2.255.254 (10.2.255.254)  2.180 ms  2.492 ms  2.648 ms</span><br><span class="line"> 3  * * *</span><br><span class="line"> 4  * * *</span><br><span class="line"> 5  * * *</span><br><span class="line"> 6  123.125.40.254 (123.125.40.254)  2.714 ms  2.634 ms  2.883 ms</span><br><span class="line"> 7  61.49.44.65 (61.49.44.65)  1.459 ms  1.448 ms  1.521 ms</span><br><span class="line"> 8  61.148.160.5 (61.148.160.5)  1.443 ms  1.466 ms  1.459 ms</span><br><span class="line"> 9  124.65.60.77 (124.65.60.77)  3.258 ms  5.805 ms  5.790 ms</span><br><span class="line"> 10  123.126.0.85 (123.126.0.85)  3.392 ms  3.202 ms  3.245 ms</span><br><span class="line">11  123.126.0.85 (123.126.0.85)  3.214 ms  5.487 ms  3.913 ms</span><br><span class="line">12  219.158.35.90 (219.158.35.90)  71.347 ms  71.338 ms  71.337 ms</span><br></pre></td></tr></table></figure><p>国内链路则直接走原本的网络环境出去.</p><h3 id="3-5-配置监控脚本"><a href="#3-5-配置监控脚本" class="headerlink" title="3.5    配置监控脚本"></a><code>3.5</code>    配置监控脚本</h3><p>由于国际出口不一定稳定, OpenVPN有可能会间歇性断掉, 如果发生此情况, 则会造成默认路由不可达, 从而导致国内网站浏览也会出现问题, 所以配置监控脚本, 一旦国际链路抽风, 则立刻将路由切换至国内.</p><p>脚本内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">       ip=&quot;172.31.188.1&quot;</span><br><span class="line">       i=-1</span><br><span class="line">       j=-1</span><br><span class="line">       while : ; do</span><br><span class="line">               ping $ip -c 5 -w 30</span><br><span class="line">               if [ $? -ge &quot;1&quot; ]; then</span><br><span class="line">               route del default gw $ip</span><br><span class="line">       j=-1</span><br><span class="line">                   i=$((i+1))</span><br><span class="line">               txt=`date +%F&quot; &quot;%X`&quot; Ping $ip timed out.&quot;</span><br><span class="line">               (($i%30==0)) &amp;&amp; echo $txt &gt;&gt; /root/bin/logs/checkip.log </span><br><span class="line">       (($i%30==0)) &amp;&amp; echo $txt | mailx -s &quot;VPN disconnected&quot; admin@domain.com</span><br><span class="line">               else</span><br><span class="line">                   route add default gw $ip</span><br><span class="line">                   i=-1</span><br><span class="line">       j=$((j+1))</span><br><span class="line">       txt=`date +%F&quot; &quot;%X`&quot; Ping $ip OK.&quot;</span><br><span class="line">       (($j%30==0)) &amp;&amp; echo $txt &gt;&gt; /root/bin/logs/checkip.log</span><br><span class="line">       (($j%100000==0)) &amp;&amp; echo $txt | mailx -s &quot;VPN OK.&quot; admin@domain.com</span><br><span class="line">               fi</span><br><span class="line">       sleep 10</span><br><span class="line">       done</span><br></pre></td></tr></table></figure><p>后台启动此脚本, 则会每10秒监控一次出国链路, 如果断掉, 将会把路由切至国内, 不影响正常上网; 如果出国链路长期无法恢复, 则每5分钟给管理员发送一封告警邮件.</p><h2 id="4-Client"><a href="#4-Client" class="headerlink" title="4.    Client"></a><code>4</code>.    Client</h2><p>客户端接入路由器所在交换机后, 配置为自动获取IP地址, 即可进行翻墙.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Arthor:    Archean Zhang&lt;/p&gt;
&lt;p&gt;Email:    &lt;a href=&quot;mailto:&amp;#122;&amp;#101;&amp;#x70;&amp;#104;&amp;#121;&amp;#x72;&amp;#52;&amp;#x32;&amp;#50;&amp;#64;&amp;#x67;&amp;#109;&amp;#x61;&amp;#x69;&amp;#108;&amp;#46;&amp;#99;&amp;#x6f;&amp;#109;&quot;&gt;&amp;#122;&amp;#101;&amp;#x70;&amp;#104;&amp;#121;&amp;#x72;&amp;#52;&amp;#x32;&amp;#50;&amp;#64;&amp;#x67;&amp;#109;&amp;#x61;&amp;#x69;&amp;#108;&amp;#46;&amp;#99;&amp;#x6f;&amp;#109;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Version:    1.0.1&lt;/p&gt;
&lt;p&gt;Date:        2013/8/16&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;长期被GFW困扰, 我终于忍不住动手了: 把家里的Raspberry Pi和与自由世界的主机建立OpenVPN over Stunnel的链路, 根据大中华3000条路由来匹配, 国外网站自动走OpenVPN出去以实现翻墙.&lt;/p&gt;
&lt;p&gt;以下文章是基于一台Linux服务器(CentOS 6.4)撰写的, 将下面&lt;code&gt;Router&lt;/code&gt;的换成Raspberry Pi也一样.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用Squid与Stunnel构建安全的http代理服务器</title>
    <link href="https://archeanz.com/2013/10/16/safe-http-proxy-over-squid-and-stunnel/"/>
    <id>https://archeanz.com/2013/10/16/safe-http-proxy-over-squid-and-stunnel/</id>
    <published>2013-10-16T12:26:07.000Z</published>
    <updated>2021-06-30T10:27:15.459Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/1519029/39092612-9a633210-4644-11e8-9f55-e238e0ef516e.jpg" alt="Squid" title="Squid"><br>使用Squid在服务器端打开一个http 验证的代理端口, 同时用服务器上的Stunnel进行转发, 与客户端的Stunnel通过SSL链接, 达到代理的目的.</p><p>也可以使用客户端的Stunnel与Squid通过SSL直接相连.</p><p>本方法使用前者.</p><span id="more"></span><h1 id="1-服务器端配置"><a href="#1-服务器端配置" class="headerlink" title="1. 服务器端配置"></a>1. 服务器端配置</h1><p>服务器环境:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># lsb_release -a</span><br><span class="line">LSB Version::core-4.0-ia32:core-4.0-noarch:graphics-4.0-ia32:graphics-4.0-noarch:printing-4.0-ia32:printing-4.0-noarch</span><br><span class="line">Distributor ID:CentOS</span><br><span class="line">Description:CentOS Linux release 6.0 (Final)</span><br><span class="line">Release:6.0</span><br><span class="line">Codename:Final</span><br><span class="line"># uname -a</span><br><span class="line">Linux jb1.archean.me 2.6.32-71.el6.i686 #1 SMP Fri Nov 12 04:17:17 GMT 2010 i686 i686 i386 GNU/Linux</span><br></pre></td></tr></table></figure><h2 id="1-1-安装Squid"><a href="#1-1-安装Squid" class="headerlink" title="1.1 安装Squid"></a>1.1 安装Squid</h2><p>下载squid 3.2.8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wget http://www.squid-cache.org/Versions/v3/3.2/squid-3.2.8.tar.gz</span><br></pre></td></tr></table></figure><p>可以使用CentOS的Yum安装工具, 不过我更喜欢编译安装(提前准备好编译环境, Gcc, openssl等):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># tar zxvf squid-3.2.8.tar.gz</span><br><span class="line"># cd squid-3.2.8</span><br><span class="line"># ./configure --prefix=/usr/local --enable-basic-auth-helpers=NCSA</span><br><span class="line"># make</span><br><span class="line"># make install</span><br></pre></td></tr></table></figure><h2 id="1-2-配置Squid"><a href="#1-2-配置Squid" class="headerlink" title="1.2 配置Squid"></a>1.2 配置Squid</h2><p>这个拓扑结构只需要Squid做简单的http代理, 所以无需SSL.</p><p>squid的配置文件在<code>/usr/local/etc/squid.conf</code></p><p>备份之后, 将其按下面修改, 为防止被别的机器滥用, 只监听127.0.0.1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">###/usr/local/etc/squid.conf</span><br><span class="line">###2013-1-27 19:56 v0.0.1 for squid 3.2.6</span><br><span class="line">#Xu Zhang &lt;zephyr422@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">visible_hostname Archean.me</span><br><span class="line">cache_mgr zephyr422@gmail.com</span><br><span class="line">http_port 127.0.0.1:3177</span><br><span class="line">icp_port 0</span><br><span class="line">cache_mem 256 MB</span><br><span class="line">dns_nameservers 8.8.8.8 8.8.4.4</span><br><span class="line"></span><br><span class="line">coredump_dir /usr/local/var/cache/squid</span><br><span class="line">access_log /usr/local/var/logs/squid_access.log</span><br><span class="line">cache_log /usr/local/var/logs/squid_cache.log</span><br><span class="line"></span><br><span class="line">auth_param basic program /usr/local/libexec/basic_ncsa_auth /usr/local/etc/squid.passwd #使用 HTTP 基本验证</span><br><span class="line">auth_param basic children 5</span><br><span class="line">auth_param basic realm Archean&#x27;s GFW Breaker Proxy, to forward, please input &quot;Username/Password&quot;.</span><br><span class="line">auth_param basic credentialsttl 7 days</span><br><span class="line">auth_param basic casesensitive off</span><br><span class="line"></span><br><span class="line">acl password proxy_auth REQUIRED</span><br><span class="line">acl localnet src 10.0.0.0/8# RFC1918 possible internal network</span><br><span class="line">acl localnet src 172.16.0.0/12# RFC1918 possible internal network</span><br><span class="line">acl localnet src 192.168.0.0/16# RFC1918 possible internal network</span><br><span class="line">acl localnet src fc00::/7       # RFC 4193 local private network range</span><br><span class="line">acl localnet src fe80::/10      # RFC 4291 link-local (directly plugged) machines</span><br><span class="line">acl SSL_ports port 443</span><br><span class="line">acl Safe_ports port 80# http</span><br><span class="line">acl Safe_ports port 21# ftp</span><br><span class="line">acl Safe_ports port 443# https</span><br><span class="line">acl Safe_ports port 70# gopher</span><br><span class="line">acl Safe_ports port 210# wais</span><br><span class="line">acl Safe_ports port 1025-65535# unregistered ports</span><br><span class="line">acl Safe_ports port 280# http-mgmt</span><br><span class="line">acl Safe_ports port 488# gss-http</span><br><span class="line">acl Safe_ports port 591# filemaker</span><br><span class="line">acl Safe_ports port 777# multiling http</span><br><span class="line">acl CONNECT method CONNECT</span><br><span class="line"></span><br><span class="line">http_access allow password</span><br><span class="line"></span><br><span class="line">http_access deny !Safe_ports</span><br><span class="line">http_access deny CONNECT !SSL_ports</span><br><span class="line">http_access allow localnet</span><br><span class="line">http_access allow localhost</span><br><span class="line"></span><br><span class="line">http_access deny all</span><br></pre></td></tr></table></figure><p>检查配置有没有问题:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># squid -k check</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># squid -k parse</span><br></pre></td></tr></table></figure><p>生成密码文件(<code>-c</code>), 创建账户. (如果没有<code>htpasswd</code>需要安装 httpd, 略)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># htpasswd -c /usr/local/etc/squid.passwd archean</span><br><span class="line">new password</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>初始化cache目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># squid -z</span><br></pre></td></tr></table></figure><p>一旦你已经初始化cache目录，就可以在终端窗口里运行squid，将日志记录到标准错误。这样，就能轻易的定位任何错误或问题，并且确认squid是否成功启动。使用-N选项来保持squid在前台运行，-d1选项在标准错误里显示1级别的调试信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># squid -N -d1</span><br></pre></td></tr></table></figure><p>启动squid:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># squid</span><br></pre></td></tr></table></figure><p>检查是否启动成功, <code>ps -ef | grep squid</code> 或 <code>lsof -i:3177</code></p><p>模拟测试客户端连接:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># squidclient -p 3177 http://www.squid-cache.org/</span><br></pre></td></tr></table></figure><p>如期返回了html信息, 说明Squid已成功启动.</p><h2 id="1-3-安装Stunnel"><a href="#1-3-安装Stunnel" class="headerlink" title="1.3 安装Stunnel"></a>1.3 安装Stunnel</h2><p>下载稳定版Stunnel</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wget https://www.stunnel.org/downloads/stunnel-4.56.tar.gz</span><br></pre></td></tr></table></figure><p>创建Stunnel用户:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /usr/sbin/groupadd -g 122 stunnel</span><br><span class="line"># /usr/sbin/useradd -c stunnel -d /nonexistent -m -g 122 -u 122 stunnel</span><br></pre></td></tr></table></figure><p>安装:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># tar zxvf stunnel-4.56.tar.gz</span><br><span class="line"># cd stunnel-4.56</span><br><span class="line"># ./configure --prefix=/usr/local</span><br><span class="line"># make</span><br><span class="line"># makeinstall</span><br></pre></td></tr></table></figure><p>安装过程通常会创建自签名证书, 会放到<code>/usr/local/etc/stunnel/stunnel.pem</code>可以直接使用(有效期一年). 使用下面的命令检查证书详细内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># openssl x509 -subject -dates -fingerprint -in stunnel.pem </span><br><span class="line">subject= /C=CN/ST=Beijing/L=Beijing/O=Archean Inc/OU=Archean Inc/CN=archean.me</span><br><span class="line">notBefore=Apr 20 02:05:24 2013 GMT</span><br><span class="line">notAfter=Apr 20 02:05:24 2014 GMT</span><br><span class="line">SHA1 Fingerprint=87:F8:6E:05:B8:9C:BC:A1:EA:15:B7:C9:B4:B2:75:FF:8A:CA:C5:FA</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">xxx</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure><p>给证书生成 Diffie-Hellman 部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># openssl gendh 512&gt;&gt; stunnel.pem </span><br></pre></td></tr></table></figure><p>这在4.x版本的stunnel上好像是必须的.</p><p>如果想要自己生成证书, 命令如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># openssl req -new -x509 -days 365 -nodes -config openssl.cnf -out stunnel.pem -keyout stunnel.pem </span><br></pre></td></tr></table></figure><h2 id="1-4-配置Stunnel"><a href="#1-4-配置Stunnel" class="headerlink" title="1.4 配置Stunnel"></a>1.4 配置Stunnel</h2><p>在<code>/usr/local/etc/stunnel/</code>下创建stunnel.conf, 写入如下配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cert = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">CAfile = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">socket = l:TCP_NODELAY=1</span><br><span class="line">socket = r:TCP_NODELAY=1</span><br><span class="line"></span><br><span class="line">;;;chroot = /var/run/stunnel</span><br><span class="line">pid = /tmp/stunnel.pid</span><br><span class="line">verify = 3</span><br><span class="line"></span><br><span class="line">;;; CApath = certs</span><br><span class="line">;;; CRLpath = crls</span><br><span class="line">;;; CRLfile = crls.pem</span><br><span class="line"></span><br><span class="line">setuid = stunnel</span><br><span class="line">setgid = stunnel</span><br><span class="line"></span><br><span class="line">;;; client=yes</span><br><span class="line">compression = zlib</span><br><span class="line">;;; taskbar = no</span><br><span class="line">delay = no</span><br><span class="line">;;; failover = rr</span><br><span class="line">;;; failover = prio</span><br><span class="line">sslVersion = TLSv1</span><br><span class="line">fips=no</span><br><span class="line"></span><br><span class="line">debug = 7</span><br><span class="line">syslog = no</span><br><span class="line">output = stunnel.log</span><br><span class="line"></span><br><span class="line">[sproxy]</span><br><span class="line">accept = 34567</span><br><span class="line">connect = 127.0.0.1:3177</span><br></pre></td></tr></table></figure><p>此时便可启动stunnel:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># stunnel</span><br></pre></td></tr></table></figure><p>检查是否运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ps -ef | grep stunnel</span><br><span class="line"># lsof -i:34567</span><br></pre></td></tr></table></figure><h2 id="1-5-将Squid和Stunnel加入开机启动项"><a href="#1-5-将Squid和Stunnel加入开机启动项" class="headerlink" title="1.5 将Squid和Stunnel加入开机启动项"></a>1.5 将Squid和Stunnel加入开机启动项</h2><p>略</p><h1 id="2-客户端配置"><a href="#2-客户端配置" class="headerlink" title="2. 客户端配置"></a>2. 客户端配置</h1><h2 id="2-1-linux客户端使用stunnel与服务器进行安全连接"><a href="#2-1-linux客户端使用stunnel与服务器进行安全连接" class="headerlink" title="2.1 linux客户端使用stunnel与服务器进行安全连接"></a>2.1 linux客户端使用stunnel与服务器进行安全连接</h2><p>安装Stunnel</p><p>与服务器完全相同, 略.</p><h2 id="2-2-配置客户端Stunnel"><a href="#2-2-配置客户端Stunnel" class="headerlink" title="2.2 配置客户端Stunnel"></a>2.2 配置客户端Stunnel</h2><p>将服务器生成的证书传到客户端中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/etc/stunnel</span><br><span class="line"># scp root@jb1.archean.me:/usr/local/etc/stunnel/stunnel.pem ./</span><br></pre></td></tr></table></figure><p>创建配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim stunnel.conf</span><br></pre></td></tr></table></figure><p>内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">id = /tmp/stunnel.pid</span><br><span class="line">cert = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">socket = l:TCP_NODELAY=1</span><br><span class="line">socket = r:TCP_NODELAY=1</span><br><span class="line">verify = 2</span><br><span class="line">CAfile = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">client=yes</span><br><span class="line">compression = zlib</span><br><span class="line">ciphers = AES256-SHA</span><br><span class="line">delay = no</span><br><span class="line">failover = prio</span><br><span class="line">sslVersion = TLSv1</span><br><span class="line">fips = no</span><br><span class="line">[sproxy]</span><br><span class="line">accept  = 0.0.0.0:7071</span><br><span class="line">connect = jb1.archean.me:34567</span><br></pre></td></tr></table></figure><p>其中accept是本地代理监听地址, 如不对外提供服务则改为<code>accept = 127.0.0.1:7071</code></p><p>启动stunnel:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/bin/stunnel</span><br></pre></td></tr></table></figure><p>至此, 配置完全结束, 可以通过使用<code>Client.IP.Address:7071</code>代理上网</p><h2 id="2-3-结语"><a href="#2-3-结语" class="headerlink" title="2.3 结语"></a>2.3 结语</h2><p>参考资料:</p><p><a href="http://home.arcor.de/pangj/squid/index.html">Squid权威指南</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/1519029/39092612-9a633210-4644-11e8-9f55-e238e0ef516e.jpg&quot; alt=&quot;Squid&quot; title=&quot;Squid&quot;&gt;&lt;br&gt;使用Squid在服务器端打开一个http 验证的代理端口, 同时用服务器上的Stunnel进行转发, 与客户端的Stunnel通过SSL链接, 达到代理的目的.&lt;/p&gt;
&lt;p&gt;也可以使用客户端的Stunnel与Squid通过SSL直接相连.&lt;/p&gt;
&lt;p&gt;本方法使用前者.&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://archeanz.com/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>为nginx配置https并自签名证书</title>
    <link href="https://archeanz.com/2013/10/16/enable-nginx-ssl/"/>
    <id>https://archeanz.com/2013/10/16/enable-nginx-ssl/</id>
    <published>2013-10-16T11:44:25.000Z</published>
    <updated>2021-06-30T10:27:15.459Z</updated>
    
    <content type="html"><![CDATA[<p>为了使网站可以使用加密的方式访问, 我们有时需要配置https, 此文章简单介绍一下方法.<br>##把证书准备好。</p><p>###制作CA证书：</p><p>ca.key CA私钥：</p><pre><code>openssl genrsa -des3 -out ca.key 2048</code></pre><p>制作解密后的CA私钥（一般无此必要）：</p><pre><code>openssl rsa -in ca.key -out ca_decrypted.key</code></pre><p>ca.crt CA根证书（公钥）：</p><pre><code>openssl req -new -x509 -days 7305 -key ca.key -out ca.crt</code></pre><span id="more"></span><p>###制作生成网站的证书并用CA签名认证<br>在这里，假设网站域名为<code>blog.archean.me</code></p><p>生成blog.archean.me证书私钥：</p><pre><code>openssl genrsa -des3 -out blog.archean.me.pem 1024</code></pre><p>制作解密后的blog.archean.me证书私钥：</p><pre><code>openssl rsa -in blog.archean.me.pem -out blog.archean.me.key</code></pre><p>生成签名请求：</p><pre><code>openssl req -new -key blog.archean.me.pem -out blog.archean.me.csr</code></pre><p>在common name中填入网站域名，如blog.archean.me即可生成改站点的证书，同时也可以使用泛域名如<code>*.archean.me</code>来生成所有二级域名可用的网站证书。</p><p>用CA进行签名：</p><pre><code>openssl ca -policy policy_anything -days 1460 -cert ca.crt -keyfile ca.key -in blog.archean.me.csr -out blog.archean.me.crt</code></pre><p>其中，policy参数允许签名的CA和网站证书可以有不同的国家、地名等信息，days参数则是签名时限。<br>如果在执行签名命令时，出现<code>I am unable to access the ../../CA/newcerts directory</code></p><pre><code>修改/etc/pki/tls/openssl.cnf中“dir = ./CA”</code></pre><p>然后：</p><pre><code>mkdir -p CA/newcertstouch CA/index.txttouch CA/serialecho “01″ &gt; CA/serial</code></pre><p>再重新执行签名命令。</p><p>最后，把ca.crt的内容粘贴到blog.archean.me.crt后面。这个比较重要！因为不这样做，可能会有某些浏览器不支持。<br>好了，现在https需要到的网站私钥blog.archean.me.key和网站证书blog.archean.me.crt都准备完毕。接下来开始配置服务端。</p><p>##配置nginx<br>新开一个虚拟主机，并在server{}段中设置：</p><pre><code>listen 443;ssl on;ssl_certificate /path/to/blog.archean.me.crt;ssl_certificate_key /path/to/blog.archean.me.key;</code></pre><p>其中的路径是刚刚生成的网站证书的路径。</p><p>然后使用一下命令检测配置和重新加载nginx：</p><p>检测配置：</p><pre><code>nginx -t</code></pre><p>重新加载：</p><pre><code>nginx -s reload</code></pre><p>在<a href="http://nginx.org/en/docs/http/configuring_https_servers.html">这里</a>是nginx官方的关于https的文档，可以作为参考。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了使网站可以使用加密的方式访问, 我们有时需要配置https, 此文章简单介绍一下方法.&lt;br&gt;##把证书准备好。&lt;/p&gt;
&lt;p&gt;###制作CA证书：&lt;/p&gt;
&lt;p&gt;ca.key CA私钥：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;openssl genrsa -des3 -out ca.key 2048
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;制作解密后的CA私钥（一般无此必要）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;openssl rsa -in ca.key -out ca_decrypted.key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ca.crt CA根证书（公钥）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;openssl req -new -x509 -days 7305 -key ca.key -out ca.crt
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="linux" scheme="https://archeanz.com/categories/linux/"/>
    
    <category term="web" scheme="https://archeanz.com/categories/linux/web/"/>
    
    
  </entry>
  
</feed>
