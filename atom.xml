<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Archean&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c74a4fe3b011e653347647983bd45507</icon>
  <subtitle>Knowing and Doing.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://archeanz.com/"/>
  <updated>2019-03-10T09:03:18.610Z</updated>
  <id>https://archeanz.com/</id>
  
  <author>
    <name>Archean Zhang</name>
    <email>zephyr422@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker 学习笔记</title>
    <link href="https://archeanz.com/2019/03/03/docker-learn-memo-1/"/>
    <id>https://archeanz.com/2019/03/03/docker-learn-memo-1/</id>
    <published>2019-03-03T14:10:06.000Z</published>
    <updated>2019-03-10T09:03:18.610Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司的一些服务将要迁移至 Docker 平台，为了能够理解 Docker 原理，决定自己从零开始学习 Docker 这个风靡全球的容器解决方案，将学习的过程记录下来。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Docker-在-CentOS-6-10-上的安装"><a href="#Docker-在-CentOS-6-10-上的安装" class="headerlink" title="Docker 在 CentOS 6.10 上的安装"></a>Docker 在 CentOS 6.10 上的安装</h3><p>公司的系统使用的是 CentOS 6，所以先将内核升级至 3.10 以上版本</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">yum install https://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm</span><br><span class="line">yum --enablerepo=elrepo-kernel install kernel-lt -y</span><br></pre></td></tr></table></figure><p>之后使用下面的命令将 Docker 源加入到 yum 源中</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tee /etc/yum.repos.d/docker.repo &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">[dockerrepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>之后运行下面的命令安装、启动 Docker</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-engine</span><br><span class="line">service docker start</span><br></pre></td></tr></table></figure><h3 id="中间遇到很多问题，大概列举一下"><a href="#中间遇到很多问题，大概列举一下" class="headerlink" title="中间遇到很多问题，大概列举一下"></a>中间遇到很多问题，大概列举一下</h3><ul><li>docker: relocation error: docker: symbol dm_task_get_info_with_deferred_remove, version Base not defined in file libdevmapper.so.1.02 with link time reference</li></ul><p>这个是说 <code>device-mapper</code> 版本过低，升级一下</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update device-mapper</span><br></pre></td></tr></table></figure><ul><li>FATAL: Module bridge not found.</li></ul><p>内核版本问题，升级到 3.10 以上解决</p><ul><li>FATA[0000] Error starting daemon: Error initializing network controller: Error creating default “bridge” network: can’t find an address range for interface “docker0” </li></ul><p>此错误是因为公司内网有 172.16.0.0/16 的路由表，将 docker0 的网卡网段占用了导致的，通过在 <code>/etc/sysconfig/docker</code> 中增加以下参数，强制让 Docker 创建虚拟机时使用特定网段来解决：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">other_args=&quot;-bip=192.168.100.1/24&quot;</span><br></pre></td></tr></table></figure><ul><li>拉取镜像提示 Get <a href="https://index.docker.io/v1/repositories/library/hello-world/images" target="_blank" rel="noopener">https://index.docker.io/v1/repositories/library/hello-world/images</a>: dial tcp 52.207.42.240:443: network is unreachable</li></ul><p>这个肯定是网络问题了，公司的标准服务器是没有办法上外网的，系统环境变量中指定我自己的代理服务器居然也不管用，尝试了多种方法，目前问题还没解决</p><h3 id="Docker-在-Ubuntu-16-04-上的安装"><a href="#Docker-在-Ubuntu-16-04-上的安装" class="headerlink" title="Docker 在 Ubuntu 16.04 上的安装"></a>Docker 在 Ubuntu 16.04 上的安装</h3><p>由于 Docker 最早就是在 Ubuntu 上发展出来的，这里也记录下 Ubuntu 16.04 的安装方法</p><p>首先，安装 Docker 官方仓库的 GPG key 到系统中<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></p><p>添加 Docker apt 源<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure></p><p>然后，进行一下更新<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></p><p>确认 Docker repo 可以安装<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache policy docker-ce</span><br></pre></td></tr></table></figure></p><p>如果看到下面的内容说明是 OK 的<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Output of apt-cache policy docker-ce</span><br><span class="line">docker-ce:</span><br><span class="line">  Installed: (none)</span><br><span class="line">  Candidate: 18.06.1~ce~3-0~ubuntu</span><br><span class="line">  Version table:</span><br><span class="line">     18.06.1~ce~3-0~ubuntu 500</span><br><span class="line">        500 https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages</span><br></pre></td></tr></table></figure></p><p>安装 Docker<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y docker-ce</span><br></pre></td></tr></table></figure></p><p>确认 Docker 是否已经安装<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure></p><p>类似下面的输出说明正确安装了</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Thu 2018-10-18 20:28:23 UTC; 35s ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 13412 (dockerd)</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           ├─13412 /usr/bin/dockerd -H fd://</span><br><span class="line">           └─13421 docker-containerd --config /var/run/docker/containerd/containerd.toml</span><br></pre></td></tr></table></figure><p>另外，docker run 仍然是提示网络问题无法访问，跟 CentOS 一样无论如何加代理都不行<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker run hello-world</span><br><span class="line">Unable to find image &apos;hello-world:latest&apos; locally</span><br><span class="line">docker: Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers).</span><br><span class="line">See &apos;docker run --help&apos;.</span><br></pre></td></tr></table></figure></p><p>最后，只能让 Docker Host 直接连接外网来解决这个问题。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="执行-Docker-命令"><a href="#执行-Docker-命令" class="headerlink" title="执行 Docker 命令"></a>执行 Docker 命令</h3><p>开始了解 Docker 命令，最简单的方法就是执行 Hello World 了</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br></pre></td></tr></table></figure><p>成功后会看到如下的输出：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="运行一个-Docker-容器"><a href="#运行一个-Docker-容器" class="headerlink" title="运行一个 Docker 容器"></a>运行一个 Docker 容器</h3><p>hello-world 这个镜像的作用是输出一段文本然后退出，每一个 Docker 容器其实都是一个有特定功能的应用，比如 <code>ubuntu</code> 这个镜像，就是一个 Ubuntu 虚拟机。</p><p>试着运行一个</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -d ubuntu</span><br><span class="line"></span><br><span class="line"># -it 参数可以让我们交互式的 shell 进入容器</span><br></pre></td></tr></table></figure><p>这个时候会输出一段字符串，这段字符串可以理解为 Docker 容器 ID</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41b162b9dd3f4dc2b7d37bf195a2c4f09d38a05cf750cfbf07e90313da2a3995</span><br></pre></td></tr></table></figure><p>这个时候，我们就可以进入这个容器内，去一看究竟了<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it 41b16 /bin/bash</span><br><span class="line"></span><br><span class="line">root@41b162b9dd3f:/# ps -ef </span><br><span class="line"></span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 07:09 pts/0    00:00:00 /bin/bash</span><br><span class="line">root        10     0  0 07:11 pts/1    00:00:00 /bin/bash</span><br><span class="line">root        21    10  0 07:13 pts/1    00:00:00 ps -ef</span><br></pre></td></tr></table></figure></p><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>用一段时间的 Docker 之后，我们可能会有很多运行中的和非运行状态的容器，怎么去管理它们呢？</p><h3 id="查看-Docker-容器"><a href="#查看-Docker-容器" class="headerlink" title="查看 Docker 容器"></a>查看 Docker 容器</h3><p>docker ps 命令可以让我们看到目前运行中的 Docker 容器情况</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">41b162b9dd3f        ubuntu              &quot;/bin/bash&quot;              5 minutes ago       Up 5 minutes                                 zealous_murdock</span><br><span class="line">47651cfa1d8e        golang              &quot;bash&quot;                   14 hours ago        Up 14 hours                                  optimistic_lederberg</span><br><span class="line">3b80522e5902        busybox             &quot;sh&quot;                     37 hours ago        Up 37 hours                                  zealous_darwin</span><br><span class="line">8b881720ceb8        redis               &quot;docker-entrypoint.s…&quot;   37 hours ago        Up 37 hours         0.0.0.0:6379-&gt;6379/tcp   musing_noyce</span><br><span class="line">f3f14f20b61f        nginx               &quot;nginx -g &apos;daemon of…&quot;   37 hours ago        Up 37 hours         80/tcp                   zealous_blackburn</span><br></pre></td></tr></table></figure><p>奇怪，我们刚才运行的 Hello World 没有在列表里，什么原因呢？</p><p>其实 Hello World 属于非活动状态的镜像，只要给 <code>docker ps</code> 命令加上 <code>-a</code> 参数就可以看到了</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                    NAMES</span><br><span class="line">41b162b9dd3f        ubuntu              &quot;/bin/bash&quot;              6 minutes ago       Up 6 minutes                                         zealous_murdock</span><br><span class="line">258796d0e4ed        hello-world         &quot;/hello&quot;                 12 minutes ago      Exited (0) 12 minutes ago                            trusting_swartz</span><br><span class="line">47651cfa1d8e        golang              &quot;bash&quot;                   14 hours ago        Up 14 hours                                          optimistic_lederberg</span><br><span class="line">3b80522e5902        busybox             &quot;sh&quot;                     37 hours ago        Up 37 hours                                          zealous_darwin</span><br><span class="line">8b881720ceb8        redis               &quot;docker-entrypoint.s…&quot;   37 hours ago        Up 37 hours                 0.0.0.0:6379-&gt;6379/tcp   musing_noyce</span><br><span class="line">0a02170a956f        hello-world         &quot;/hello&quot;                 37 hours ago        Exited (0) 37 hours ago                              determined_mestorf</span><br><span class="line">f3f14f20b61f        nginx               &quot;nginx -g &apos;daemon of…&quot;   37 hours ago        Up 37 hours                 80/tcp                   zealous_blackburn</span><br><span class="line">b43d4f2ba5ed        ubuntu              &quot;/bin/bash&quot;              37 hours ago        Exited (0) 7 minutes ago                             unruffled_snyder</span><br><span class="line">66aa497d9767        ubuntu              &quot;/bin/bash&quot;              37 hours ago        Exited (0) 37 hours ago                              hungry_boyd</span><br><span class="line">126e0f019b19        ubuntu              &quot;/bin/bash&quot;              37 hours ago        Exited (0) 37 hours ago                              competent_goldwasser</span><br><span class="line">600adf161623        ubuntu              &quot;/bin/bash&quot;              37 hours ago        Exited (0) 37 hours ago                              upbeat_thompson</span><br><span class="line">3b5d4380392f        ubuntu              &quot;/bin/bash&quot;              37 hours ago        Exited (0) 37 hours ago                              pedantic_euclid</span><br><span class="line">4fd577a1e8bf        ubuntu              &quot;/bin/bash&quot;              37 hours ago        Exited (0) 37 hours ago                              upbeat_mcnulty</span><br></pre></td></tr></table></figure><p>而如果使用 <code>-l</code> 参数，则可以看到最近创建的 Docker 容器</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -l</span><br><span class="line"></span><br><span class="line">CONTAINER ID  IMAGE COMMAND CREATED STATUS  PORTS NAMES</span><br><span class="line">41b162b9dd3f  ubuntu  &quot;/bin/bash&quot; 10 minutes ago  Up 10 minutes zealous_murdock</span><br></pre></td></tr></table></figure><h3 id="关闭一个-Docker-容器"><a href="#关闭一个-Docker-容器" class="headerlink" title="关闭一个 Docker 容器"></a>关闭一个 Docker 容器</h3><p>我们在测试过程中运行了很多容器实例了，一些容器不需要再去使用了，</p><p>使用 <code>docker stop</code> 命令可以将活动状态的容器停止运行<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop 41b162b9dd3f</span><br></pre></td></tr></table></figure></p><p>不仅可以使用 container ID 指定容器，还可以使用容器别名来操作<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop zealous_murdock</span><br><span class="line"></span><br><span class="line">zealous_murdock</span><br></pre></td></tr></table></figure></p><p>停止运行的容器就可以关掉了，这里使用的命令是 <code>docker rm</code></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># docker rm zealous_murdock</span><br><span class="line"></span><br><span class="line">zealous_murdock</span><br></pre></td></tr></table></figure><ul><li>overlay2 代替 auFS 作为新的 Union File System 来使用</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近公司的一些服务将要迁移至 Docker 平台，为了能够理解 Docker 原理，决定自己从零开始学习 Docker 这个风靡全球的容器解决方案，将学习的过程记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://archeanz.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>试一下 Hexo 新主题：icarus</title>
    <link href="https://archeanz.com/2019/03/01/test-new-theme/"/>
    <id>https://archeanz.com/2019/03/01/test-new-theme/</id>
    <published>2019-03-01T17:50:08.000Z</published>
    <updated>2019-03-10T09:07:03.526Z</updated>
    
    <content type="html"><![CDATA[<p>最近将主题从从切换到 icarus，感觉很不错，新建一篇文章试一下。</p><a id="more"></a><div class="justified-gallery"><br><img src="https://i.imgur.com/IOx2H0T.jpg" alt><br><img src="https://i.imgur.com/RMWMa5W.jpg" alt><br><img src="https://i.imgur.com/2esmTkr.jpg" alt><br><img src="https://i.imgur.com/rffaYsC.jpg" alt><br><img src="https://i.imgur.com/YuvGNhv.jpg" alt><br><img src="https://i.imgur.com/DBcmGd4.jpg" alt><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近将主题从从切换到 icarus，感觉很不错，新建一篇文章试一下。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo 持续集成</title>
    <link href="https://archeanz.com/2019/01/28/hexo-auto-deploy-by-travis-ci/"/>
    <id>https://archeanz.com/2019/01/28/hexo-auto-deploy-by-travis-ci/</id>
    <published>2019-01-28T17:56:57.000Z</published>
    <updated>2019-03-10T06:55:44.735Z</updated>
    
    <content type="html"><![CDATA[<p>先把操作步骤写下来</p><p>如果要在一台新的机器上，或者别的机器写博客：</p><ul><li>git clone <a href="https://github.com/iarchean/iarchean.github.io.git" target="_blank" rel="noopener">https://github.com/iarchean/iarchean.github.io.git</a></li><li>cd iarchean.github.io</li><li>npm install hexo-cli -g</li><li>hexo new post example.md</li><li>git commit  &amp; git push</li><li>done.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先把操作步骤写下来&lt;/p&gt;
&lt;p&gt;如果要在一台新的机器上，或者别的机器写博客：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git clone &lt;a href=&quot;https://github.com/iarchean/iarchean.github.io.git&quot; target=&quot;_blan
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git Submodule 引发的问题</title>
    <link href="https://archeanz.com/2018/04/22/git-submodule/"/>
    <id>https://archeanz.com/2018/04/22/git-submodule/</id>
    <published>2018-04-22T15:24:18.000Z</published>
    <updated>2019-01-28T17:53:11.012Z</updated>
    
    <content type="html"><![CDATA[<p>做 Hexo 持续集成时发现 Repo 中的 Repo 总是无法提交，原来是 Submodule 的问题，看来还是要多读书。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做 Hexo 持续集成时发现 Repo 中的 Repo 总是无法提交，原来是 Submodule 的问题，看来还是要多读书。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用Linux做路由器</title>
    <link href="https://archeanz.com/2014/02/07/NAT-on-linux/"/>
    <id>https://archeanz.com/2014/02/07/NAT-on-linux/</id>
    <published>2014-02-07T10:25:39.000Z</published>
    <updated>2019-03-10T09:05:22.767Z</updated>
    
    <content type="html"><![CDATA[<p>今日完成了一个专线项目, 根据集团要求, 需要使用 NAT 的方式联通两个办公区之间的内部网络, 使得可以互相访问服务器资源, 并且保存3个月的 NAT 日志, 出问题可以快速定位到人.</p><p>由于我们办公区没有路由器设备, 于是采用 Linux 服务器做 iptables 转发来实现 NAT 功能, 并且 iptables 可以记录日志; 此项目设计的客户端和服务器不足百台, 不会有太高的并发访问, 一台中等配置的 Linux 服务器完全可以满足要求. </p><a id="more"></a><h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><p><img src="https://user-images.githubusercontent.com/1519029/39084733-284f61d2-45ac-11e8-997b-63c8ebc190e6.png" alt="拓扑"><br><!--more--><br><em>我负责的区域在左侧.</em></p><ul><li>办公区和总部通过一条 20M 的 MSTP 线路相连, 互联网段是<code>172.17.176.48/29</code>.</li><li>在办公区<code>10.250.0.0/16</code>可以通过 SNAT 方式访问总部网络<code>10.44.0.0/16</code>, 源 IP 需要 NAT 为<code>172.17.176.50/29</code></li><li>在总部可以通过访问互联地址<code>172.17.176.51/29</code>访问办公区的数据库服务器<code>10.250.8.241</code></li></ul><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>首先在我们<code>10.250.0.0/16</code>这个三层交换机上增加<code>10.44.0.0/16</code>的路由:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route-static 10.44.0.0 255.255.0.0 10.250.254.251</span><br></pre></td></tr></table></figure></p><p>若要实现双向的 NAT, 还有一个必要条件是一台最小化安装的 Linux 服务器, 最少配置2个网卡, 在此场景下, 网卡配置为: </p><ul><li>eth0作为内部网卡, IP 地址是<code>10.250.254.251</code>; </li><li>eth1作为互联网卡, IP 地址是<code>172.17.176.50</code>;</li><li>eth1对端的 IP 为<code>172.17.176.49</code>.</li></ul><p>服务器的路由配置, 需要能够访问办公区正常的网络资源, 同时将10.44.0.0/16路由至互联网卡:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># netstat -nr</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">172.17.176.48   0.0.0.0         255.255.255.248 U         0 0          0 eth1</span><br><span class="line">10.250.254.0    0.0.0.0         255.255.255.0   U         0 0          0 eth0</span><br><span class="line">10.44.0.0       172.17.176.49   255.255.0.0     UG        0 0          0 eth1</span><br><span class="line">10.250.0.0      10.250.254.254  255.0.0.0       UG        0 0          0 eth0</span><br></pre></td></tr></table></figure></p><p>开启Linux 内核的转发功能, 编辑<code>/etc/sysctl.conf</code>, 加入如下语句:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure></p><h2 id="访问总部网络资源"><a href="#访问总部网络资源" class="headerlink" title="访问总部网络资源"></a>访问总部网络资源</h2><p>此步骤涉及到 SNAT 的概念.</p><p>所谓 SNAT, 即将一段 IP 包的源地址改变, 由于总部的 ACL 策略中仅允许<code>172.17.176.48/29</code>网段访问, 所以我们访问总部时就必须将源地址 NAT 为上述网段.</p><p>iptables 的 nat tables 有3个内置的 chain, 分别是<code>PREROUTING</code>, <code>POSTROUTING</code>和<code>OUTPUT</code>chain</p><blockquote><p>PREROUTING chain – Alters packets before routing. i.e Packet translation happens immediately after the packet comes to the system (and before routing). This helps to translate the destination ip address of the packets to something that matches the routing on the local server. This is used for DNAT (destination NAT).<br>POSTROUTING chain – Alters packets after routing. i.e Packet translation happens when the packets are leaving the system. This helps to translate the source ip address of the packets to something that might match the routing on the desintation server. This is used for SNAT (source NAT).<br>OUTPUT chain – NAT for locally generated packets on the firewall.</p></blockquote><p>我们需要使用的是<code>POSTROUTING</code> chain.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># iptables -A POSTROUTING -s 10.250.0.0/16 -o eth1 -j SNAT --to-source 172.17.176.50</span><br></pre></td></tr></table></figure><p>解释一下, 就是将来自<code>10.250.0.0/16</code>网段的包, 由 eth1 网口出去时的源 IP 变更为<code>172.17.176.50</code>; 我们之前已经将路由配置为访问10.44网段时都走 eth1, 所以此行解决了访问总部的问题.</p><p>如果查看, 可以看到此条目已经生效:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># iptables -L -t nat</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">NAT        all  --  10.250.0.0/16        0.0.0.0/0           to:172.17.176.50</span><br></pre></td></tr></table></figure></p><p>检查生效后可以使用<code>/etc/init.d/iptables save</code> 将此条保存到<code>/etc/sysconfig/iptables</code>中, 这样重启iptables 后也不会丢是配置.</p><h2 id="总部访问办公区服务器"><a href="#总部访问办公区服务器" class="headerlink" title="总部访问办公区服务器"></a>总部访问办公区服务器</h2><p>此步骤不仅涉及 SNAT, 还涉及到了 DNAT 的概念.</p><p>DNAT 即将一段 IP 包的目的地址改变. 此方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今日完成了一个专线项目, 根据集团要求, 需要使用 NAT 的方式联通两个办公区之间的内部网络, 使得可以互相访问服务器资源, 并且保存3个月的 NAT 日志, 出问题可以快速定位到人.&lt;/p&gt;
&lt;p&gt;由于我们办公区没有路由器设备, 于是采用 Linux 服务器做 iptables 转发来实现 NAT 功能, 并且 iptables 可以记录日志; 此项目设计的客户端和服务器不足百台, 不会有太高的并发访问, 一台中等配置的 Linux 服务器完全可以满足要求. &lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://archeanz.com/categories/linux/"/>
    
      <category term="iptables" scheme="https://archeanz.com/categories/linux/iptables/"/>
    
    
  </entry>
  
  <entry>
    <title>Secure Proxy Service</title>
    <link href="https://archeanz.com/2014/01/23/secure-proxy-service/"/>
    <id>https://archeanz.com/2014/01/23/secure-proxy-service/</id>
    <published>2014-01-23T04:32:15.000Z</published>
    <updated>2019-03-10T09:06:59.101Z</updated>
    
    <content type="html"><![CDATA[<p>###<code>0.</code> 免责声明<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此服务仅用于研究互联网技术, 使用者访问了任何网站或发表了任何言论, 不代表本人支持其观点.</span><br></pre></td></tr></table></figure></p><p>###<code>1.</code> 描述</p><p>这是一个”加密的” socks 代理服务, 使用者能够安全的访问世界上任何一个网站, 在本地网络状况正常的情况下, 可以:</p><h4 id="流畅的播放-YouTube-720P-视频-基本流畅的播放-1080P-视频"><a href="#流畅的播放-YouTube-720P-视频-基本流畅的播放-1080P-视频" class="headerlink" title="流畅的播放 YouTube 720P 视频, 基本流畅的播放 1080P 视频:"></a>流畅的播放 YouTube 720P 视频, 基本流畅的播放 1080P 视频:</h4><a id="more"></a><p><img src="https://user-images.githubusercontent.com/1519029/39092816-06600e5e-4648-11e8-985e-4fdfd16511e6.png" alt="720p"></p><h4 id="访问-Facebook-Twitter-Instagram-等网站"><a href="#访问-Facebook-Twitter-Instagram-等网站" class="headerlink" title="访问 Facebook, Twitter, Instagram 等网站."></a>访问 Facebook, Twitter, Instagram 等网站.</h4><p><img src="https://user-images.githubusercontent.com/1519029/39084726-26f13d6a-45ac-11e8-9e2e-bed4b70fea1d.png" alt="Instagram"></p><h4 id="为一些-app-提供访问支持"><a href="#为一些-app-提供访问支持" class="headerlink" title="为一些 app 提供访问支持."></a>为一些 app 提供访问支持.</h4><p><img src="https://user-images.githubusercontent.com/1519029/39084738-2948a314-45ac-11e8-9db1-6efdba95e00e.png" alt="Terminal"></p><p><img src="https://user-images.githubusercontent.com/1519029/39084723-26690238-45ac-11e8-964f-b1c313423c3e.png" alt="Github"></p><!--more--><p>###<code>2.</code> 如何使用</p><p>我会将<code>服务 IP/端口</code>(全局代理方式)和 <code>PAC URL</code>(Proxy Auto Config 方式) 以邮件形式发送到你的私人邮箱中, 获取到之后, 分别按照如下说明使用:</p><h4 id="全局代理"><a href="#全局代理" class="headerlink" title="全局代理"></a>全局代理</h4><p>在 IE 的 Lan 代理设置, Chrome 的 <a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">SwitchyOmega</a> 插件, 或 mac 的网络代理配置中填写服务 IP 及端口, 正确操作后, <code>所有 http 服务都将走代理访问</code>, 会导致部分网站访问速度变慢.</p><p><img src="https://user-images.githubusercontent.com/1519029/39084724-269d808a-45ac-11e8-9e26-c806202d95f1.png" alt="IE.Global"></p><p><img src="https://user-images.githubusercontent.com/1519029/39084713-24597da6-45ac-11e8-8c94-607e40b167f2.png" alt="Chrome.Global"></p><p><img src="https://user-images.githubusercontent.com/1519029/39084730-27cdf642-45ac-11e8-9c9d-2f051f166ce0.png" alt="MAC.Global"></p><p><img src="https://user-images.githubusercontent.com/1519029/39084727-271b3372-45ac-11e8-925b-3566cf1bc408.png" alt="iPhone.Global"></p><h4 id="Proxy-Auto-Config-文件"><a href="#Proxy-Auto-Config-文件" class="headerlink" title="Proxy Auto Config 文件"></a>Proxy Auto Config 文件</h4><p>在 IE 的 Lan 代理设置, Chrome 的 <a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">SwitchyOmega</a> 插件, 或 mac 的网络代理配置中填写 pac 文件位置, 正确操作后, pac <a href="http://jump.archean.me/pac.html" target="_blank" rel="noopener">白名单中的 http 服务</a>将走代理访问, 推荐方式.</p><p><img src="https://user-images.githubusercontent.com/1519029/39084725-26c6da2a-45ac-11e8-9259-0a0ef920b0d4.png" alt="IE.PAC"></p><p><img src="https://user-images.githubusercontent.com/1519029/39084715-2483da6a-45ac-11e8-9ef4-95f7de548753.png" alt="Chrome.PAC"></p><p><img src="https://user-images.githubusercontent.com/1519029/39084731-27f98a1e-45ac-11e8-98ce-c954bffb7754.png" alt="MAC.PAC"></p><p><img src="https://user-images.githubusercontent.com/1519029/39084728-2744cc32-45ac-11e8-8929-7e96419c9c36.png" alt="iPhone.PAC"></p><p>###<code>3.</code> 现存问题</p><h4 id="网络状况"><a href="#网络状况" class="headerlink" title="网络状况"></a>网络状况</h4><p>众所周知中国几个跨洋光缆不是那么稳定, 代理服务有时会出现网络波动及不可用(非常少, 4年中大概总计1天)的问题, 我这里有几个不同的国外服务器, 在出现异常情况时会及时切换.</p><h4 id="端口被复用"><a href="#端口被复用" class="headerlink" title="端口被复用"></a>端口被复用</h4><p>提供给你的服务端口或 PAC 文件是<code>完全开放</code>的, 意味着一旦泄露, 别人可以直接拿来用, 所以强烈建议不要与其他人共享.</p><p>关于此事, 我正研究不影响用户体验的验证方式, 后续将会改版.</p><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>虽然我保证不会这么做, 且也没什么必要, 但我是有技术手段监听你所有流量的, 请在确保不会提交隐私信息的情况下使用.</p><p>###<code>4.</code> 费用</p><p>费用是10元/月, 或100元/年, 接受 Alipay 或 PayPal 转账, 帐号均为 <a href="mailto:zephyr422@gmail.com" target="_blank" rel="noopener">zephyr422@gmail.com</a>.</p><p>如果服务由于不可抗力中断, 我会退给你剩余时间的费用.</p><p>###<code>5.</code> 一些解释</p><p><code>加密的</code>: 在国内-&gt;国外这个阶段的所有流量会经过我的加密, 不会遭遇政府的窃取.</p><p><code>访问速度</code>: 与使用人数, 本地网络状况及国际线路有关, 我会尽可能确保稳定.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###&lt;code&gt;0.&lt;/code&gt; 免责声明&lt;br&gt;&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;此服务仅用于研究互联网技术, 使用者访问了任何网站或发表了任何言论, 不代表本人支持其观点.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;###&lt;code&gt;1.&lt;/code&gt; 描述&lt;/p&gt;
&lt;p&gt;这是一个”加密的” socks 代理服务, 使用者能够安全的访问世界上任何一个网站, 在本地网络状况正常的情况下, 可以:&lt;/p&gt;
&lt;h4 id=&quot;流畅的播放-YouTube-720P-视频-基本流畅的播放-1080P-视频&quot;&gt;&lt;a href=&quot;#流畅的播放-YouTube-720P-视频-基本流畅的播放-1080P-视频&quot; class=&quot;headerlink&quot; title=&quot;流畅的播放 YouTube 720P 视频, 基本流畅的播放 1080P 视频:&quot;&gt;&lt;/a&gt;流畅的播放 YouTube 720P 视频, 基本流畅的播放 1080P 视频:&lt;/h4&gt;
    
    </summary>
    
      <category term="Web" scheme="https://archeanz.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx禁止其他域名访问</title>
    <link href="https://archeanz.com/2013/10/24/nginx-deny-other-domain-access/"/>
    <id>https://archeanz.com/2013/10/24/nginx-deny-other-domain-access/</id>
    <published>2013-10-24T05:09:50.000Z</published>
    <updated>2019-03-10T09:06:49.456Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到一则来自<a href="http://vtp.me" target="_blank" rel="noopener">@kyaky</a>的评论</p><p><img src="https://user-images.githubusercontent.com/1519029/39084734-28785f2e-45ac-11e8-9bff-f3b796eab61d.png" alt></p><p>让我也意识到这个问题的严重性:</p><p>如果别人把我的IP地址绑到他的域名上, 那我就是在为别人搭博客了. 我本以为Nginx配置中的<code>server_name</code>选项可以进行阻挡, 看来不实践真的是不能轻易下结论.</p><p><img src="https://user-images.githubusercontent.com/1519029/39084735-28ca32ea-45ac-11e8-92bc-b863bff47b36.png" alt></p><p>今天就回顾一下这个问题的所在, 及解决方案.<br><a id="more"></a><br>DNS解析场景是这样:</p><pre><code>域名    类型    IPA.com    A    a.b.c.dB.com    A    a.b.c.d</code></pre><p>现在我的网站配置的默认服务是<code>A.com.conf</code>:</p><pre><code>server {    listen 80 default;    server_name A.com;}</code></pre><p>当初我为了避免直接拿IP访问站点, 做了IP的过滤:</p><pre><code>if ( $host ~* &quot;\d+\.\d+\.\d+\.\d+&quot; ) {    return 403;}</code></pre><p>在这种情况下, 访问<code>A.com</code>会找到<code>a.b.c.d</code>这个IP, Nginx解析得知匹配到了<code>A.com.conf</code>, 于是进入document root目录进行服务.</p><p>当访问<code>B.com</code>时, DNS也会找到<code>a.b.c.d</code>这个IP, Nginx解析得知没有匹配, 于是也会进入<code>A.com.conf</code>的document root, 继续提供服务 – 因为是<code>default</code>.</p><p>当时忽略了域名绑定IP的问题, 那么我再加一条<code>if{}</code>判断, 不符合<code>archean.me</code>的都返回403, 即可解决这个问题了.</p><hr><p>但这样做显然不够优雅, 不仅陡然增加了Nginx配置文件的复杂度, 同时如果有多个域名绑定这台机器, 需要修改的地方就太多了.</p><p>所以查阅Nginx官方资料, 果然有相应的<a href="http://wiki.nginx.org/NginxVirtualHostExample" target="_blank" rel="noopener">解决办法</a></p><p>原来我没有做默认服务<code>default.conf</code>的配置, <code>A Default &quot;Catch All&quot; Server Block</code></p><pre><code>server {    listen 80 default_server;    server_name _; # This is just an invalid value which will never trigger on a real hostname.    return 403;}</code></pre><p>关键在于<code>server_name _;</code>, 这是指无效域名, 无论是IP地址, 错误的域名拼写或是未在其他虚拟主机配置中提到的域名, 均会触发<code>return 403;</code>, 显示页面不存在.</p><p>于是略加改进, 去掉其他虚拟主机中的default字段; 把<code>default.conf</code>中的<code>return 403;</code>改为重定向到我们期望的默认首页, 即可解决我们的问题.</p><pre><code>server {    listen 80 default_server;    server_name _;    rewrite ^ http://archean.me$request_uri?;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看到一则来自&lt;a href=&quot;http://vtp.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@kyaky&lt;/a&gt;的评论&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/1519029/39084734-28785f2e-45ac-11e8-9bff-f3b796eab61d.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;让我也意识到这个问题的严重性:&lt;/p&gt;
&lt;p&gt;如果别人把我的IP地址绑到他的域名上, 那我就是在为别人搭博客了. 我本以为Nginx配置中的&lt;code&gt;server_name&lt;/code&gt;选项可以进行阻挡, 看来不实践真的是不能轻易下结论.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/1519029/39084735-28ca32ea-45ac-11e8-92bc-b863bff47b36.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;今天就回顾一下这个问题的所在, 及解决方案.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="https://archeanz.com/categories/nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>The Great Gatsby</title>
    <link href="https://archeanz.com/2013/10/22/the-great-gatsby/"/>
    <id>https://archeanz.com/2013/10/22/the-great-gatsby/</id>
    <published>2013-10-22T15:51:02.000Z</published>
    <updated>2019-03-10T09:07:09.271Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚陪看了<a href="http://movie.douban.com/subject/3364223/" target="_blank" rel="noopener">the Great Gatsby</a>, 有感于莱昂纳多精湛的演绎, 电影绝美的画面以及这个凄美的梦.</p><p>电影的原著小说是看过的，但是莱昂纳多演绎下的盖茨比，真的非常立体丰富，特别是在电影中间他与黛西间面前紧张、局促、不安的表现，简直呈现的淋漓尽致。<br><a id="more"></a></p><h3 id="Young-And-Beautiful"><a href="#Young-And-Beautiful" class="headerlink" title="Young And Beautiful"></a>Young And Beautiful</h3><blockquote><p>I’ve seen the world<br>Done it all<br>Had my cake now<br>Diamonds, brilliant<br>And Bel Air now<br>Hot summer nights, mid July<br>When you and I were forever wild<br>The crazy days, city lights<br>The way you’d play with me like a child</p></blockquote><blockquote><p>Will you still love me<br>When I’m no longer young and beautiful?</p></blockquote><div class="justified-gallery"><br><img src="https://user-images.githubusercontent.com/1519029/39084717-250829f0-45ac-11e8-89a3-1cfc2ccf494e.jpg" alt><br><img src="https://user-images.githubusercontent.com/1519029/39084718-2534e8aa-45ac-11e8-9a3f-d3e3a885eb69.jpg" alt><br><img src="https://user-images.githubusercontent.com/1519029/39084719-2587315a-45ac-11e8-82d9-1b71a0d96d45.jpg" alt><br><img src="https://user-images.githubusercontent.com/1519029/39084720-25b332c8-45ac-11e8-9250-289d708588a5.jpg" alt><br><img src="https://user-images.githubusercontent.com/1519029/39084721-25ed2a50-45ac-11e8-99bf-0768ba7c70ca.jpg" alt><br><img src="https://user-images.githubusercontent.com/1519029/39084722-263e9976-45ac-11e8-8a95-1f9c1ebb8885.jpg" alt><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚刚陪看了&lt;a href=&quot;http://movie.douban.com/subject/3364223/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;the Great Gatsby&lt;/a&gt;, 有感于莱昂纳多精湛的演绎, 电影绝美的画面以及这个凄美的梦.&lt;/p&gt;
&lt;p&gt;电影的原著小说是看过的，但是莱昂纳多演绎下的盖茨比，真的非常立体丰富，特别是在电影中间他与黛西间面前紧张、局促、不安的表现，简直呈现的淋漓尽致。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="movie" scheme="https://archeanz.com/tags/movie/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu Server 下安装 Mcrypt PHP extension</title>
    <link href="https://archeanz.com/2013/10/22/install-mcrypt-php-extension-on-ubuntu-server/"/>
    <id>https://archeanz.com/2013/10/22/install-mcrypt-php-extension-on-ubuntu-server/</id>
    <published>2013-10-22T15:41:37.000Z</published>
    <updated>2019-03-10T09:06:40.140Z</updated>
    
    <content type="html"><![CDATA[<p>Laravel4框架需要PHP 5.4以上及Mcrypt PHP extension, 折腾了半天, 记录下备忘.</p><p>安装Mcrypt包, 顺便安装php开发环境</p><pre><code>$ sudo apt-get install php5-mcrypt php5-dev</code></pre><p>将配置文件链接给PHP</p><pre><code>$ sudo ln -s /etc/php5/conf.d/mcrypt.ini /etc/php5/mods-available</code></pre><p>开启Mcrypt模块</p><pre><code>$ sudo php5enmod mcrypt</code></pre><p>重启Nginx, PHP-FPM</p><pre><code>$ sudo /etc/init.d/nginx restart$ sudo service php5-fpm restart</code></pre><p>此时重新执行<code>php artisan</code>, all is well.</p><p>Hope can help you.</p><p><em>Oct, 24 update:</em></p><p>后来知道这是Ununtu 13.10的一个<a href="https://bugs.launchpad.net/ubuntu/+source/php-mcrypt/+bug/1241286" target="_blank" rel="noopener">Bug</a>, 按如上操作完成后重启一次php5-fpm即可彻底解决.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Laravel4框架需要PHP 5.4以上及Mcrypt PHP extension, 折腾了半天, 记录下备忘.&lt;/p&gt;
&lt;p&gt;安装Mcrypt包, 顺便安装php开发环境&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install php5-mcrypt
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用 Dropbox public folder 做博客的超稳定图床</title>
    <link href="https://archeanz.com/2013/10/21/make-dropbox-public-folder-a-stable-pic-server/"/>
    <id>https://archeanz.com/2013/10/21/make-dropbox-public-folder-a-stable-pic-server/</id>
    <published>2013-10-21T15:52:35.000Z</published>
    <updated>2019-03-10T09:06:43.395Z</updated>
    
    <content type="html"><![CDATA[<p>这个Blog是搭建在<a href="https://www.digitalocean.com/?refcode=87b0301d5ece" target="_blank" rel="noopener">Digital Ocean</a>上的, 这个VPS还是很不错的, 加州的节点在天朝访问速度非常可以, 拥有20G SSD磁盘和每月1T的流量, 只需5$, 还是非常超值的.</p><p>但是即便如此, Blog需要的大量图片等元素还是非常占用空间的, 所以只好想办法寻找一个稳定的图床来存. 我一直是Dropbox的重度用户, 自然想到她的Public Folder. </p><blockquote><p>Dropbox Public目录每日限制流量 20G, <a href="https://www.dropbox.com/help/45/en" target="_blank" rel="noopener">来源</a></p></blockquote><a id="more"></a><p>Dropbox Public Folder的地址是<code>https://dl.dropboxusercontent/u/idxxxxxxxx/</code>, Blog引用起来不够优雅, 于是萌生了此文.</p><p>配置起来非常简单, 经过我的反复实践, Nginx vhost最小配置为:</p><pre><code>server {    listen 80;    server_name img.archean.me;    root /path/to/www/root; #也可省略    location / {        rewrite /(.*) /u/DropboxID/img/$1 break;        proxy_pass https://dl.dropboxusercontent.com/;    }}</code></pre><p>此配置足以使用, 最终效果是当我访问<code>http://img.archean.me/1.jpg</code>时, 可以显示<code>https://dl.dropboxusercontent.com/u/19060928/img/1.jpg</code>的图片</p><p><img src="https://user-images.githubusercontent.com/1519029/39084716-24dedf0a-45ac-11e8-977a-c2605e759505.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个Blog是搭建在&lt;a href=&quot;https://www.digitalocean.com/?refcode=87b0301d5ece&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Digital Ocean&lt;/a&gt;上的, 这个VPS还是很不错的, 加州的节点在天朝访问速度非常可以, 拥有20G SSD磁盘和每月1T的流量, 只需5$, 还是非常超值的.&lt;/p&gt;
&lt;p&gt;但是即便如此, Blog需要的大量图片等元素还是非常占用空间的, 所以只好想办法寻找一个稳定的图床来存. 我一直是Dropbox的重度用户, 自然想到她的Public Folder. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dropbox Public目录每日限制流量 20G, &lt;a href=&quot;https://www.dropbox.com/help/45/en&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搞定 Hexo</title>
    <link href="https://archeanz.com/2013/10/20/fulfil-with-hexo-theme/"/>
    <id>https://archeanz.com/2013/10/20/fulfil-with-hexo-theme/</id>
    <published>2013-10-20T15:05:05.000Z</published>
    <updated>2019-03-10T09:06:32.190Z</updated>
    
    <content type="html"><![CDATA[<p>经过几天的摸索, 实践, 初步搞定了Hexo, 也自己试着修改了一个主题, 折腾真的是无止境的.</p><p>回头静下心来的时候把这段时间折腾的成果整理一下, 算是对学习的总结.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过几天的摸索, 实践, 初步搞定了Hexo, 也自己试着修改了一个主题, 折腾真的是无止境的.&lt;/p&gt;
&lt;p&gt;回头静下心来的时候把这段时间折腾的成果整理一下, 算是对学习的总结.&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用一台Raspberry Pi作为家庭网关, 无障碍翻墙</title>
    <link href="https://archeanz.com/2013/10/16/breaking-gfw-with-raspberry-pi/"/>
    <id>https://archeanz.com/2013/10/16/breaking-gfw-with-raspberry-pi/</id>
    <published>2013-10-16T13:57:37.000Z</published>
    <updated>2019-03-11T14:46:51.333Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Arthor:    Archean Zhang</p><p>Email:    <a href="mailto:zephyr422@gmail.com" target="_blank" rel="noopener">zephyr422@gmail.com</a></p><p>Version:    1.0.1</p><p>Date:        2013/8/16</p></blockquote><p>长期被GFW困扰, 我终于忍不住动手了: 把家里的Raspberry Pi和与自由世界的主机建立OpenVPN over Stunnel的链路, 根据大中华3000条路由来匹配, 国外网站自动走OpenVPN出去以实现翻墙.</p><p>以下文章是基于一台Linux服务器(CentOS 6.4)撰写的, 将下面<code>Router</code>的换成Raspberry Pi也一样.<br><a id="more"></a></p><h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.    准备"></a><code>1</code>.    准备</h2><p>硬件:</p><ul><li>1台位于自由世界的Linux服务器 (Server)</li><li>1台位于本地的Linux服务器 (Router)</li><li>客户端 (Client)</li></ul><p>软件:</p><ul><li>Stunnel</li><li>OpenVPN</li><li>DNSMasq</li></ul><p>拓扑图:<br><img src="https://user-images.githubusercontent.com/1519029/39084736-28f4b74a-45ac-11e8-8eee-2b550f692f7d.png" alt="Topology"></p><h2 id="2-Server端配置"><a href="#2-Server端配置" class="headerlink" title="2.    Server端配置"></a><code>2</code>.    Server端配置</h2><p>安装好Linux系统后(Red hat或CentOS), 同步服务器时间(非常重要):<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ntpdate time.nist.gov</span><br></pre></td></tr></table></figure></p><h3 id="2-1-OpenVPN"><a href="#2-1-OpenVPN" class="headerlink" title="2.1    OpenVPN"></a><code>2.1</code>    OpenVPN</h3><p>下载安装OpenVPN, 生成服务器端证书, OpenVPN依赖lzo, 需要一同安装:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># yum install lzo openvpn</span><br></pre></td></tr></table></figure></p><p>服务器端配置文件<code>/etc/openvpn/server.conf</code>, 范例及说明如下:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">local 127.0.0.1 #监听本地接口</span><br><span class="line">port 4443 #监听端口</span><br><span class="line">proto tcp #协议</span><br><span class="line">dev tap</span><br><span class="line">ca /etc/openvpn/keys/ca.crt#证书</span><br><span class="line">cert /etc/openvpn/keys/server.crt#证书</span><br><span class="line">dh /etc/openvpn/keys/dh1024.pem#证书</span><br><span class="line">server 172.31.189.0 255.255.255.0#网段</span><br><span class="line">client-to-client</span><br><span class="line">duplicate-cn</span><br><span class="line">keepalive 10 120</span><br><span class="line">comp-lzo</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">status openvpn-status.log#状态日志</span><br><span class="line">log-append  openvpn.log#执行日志</span><br><span class="line">verb 3</span><br></pre></td></tr></table></figure></p><p>启动openvpn:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># openvpn --config /etc/openvpn/server.conf --deamon</span><br></pre></td></tr></table></figure></p><p>观察日志, 如果出现<code>“Initialization Sequence Completed”</code>则代表启动成功.</p><h3 id="2-2-Stunnel"><a href="#2-2-Stunnel" class="headerlink" title="2.2    Stunnel"></a><code>2.2</code>    Stunnel</h3><p>Openvpn的Server端只监控本地接口, 就是为了用Stunnel将流量加密, 在Local端安全的链接, 达到加密, 混淆流量的作用, 以绕开GFW的监控.</p><p>下载安装stunnel<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># yum install stunnel</span><br></pre></td></tr></table></figure></p><p>安装过程中会生成服务器证书<code>stunnel.pem</code>, 按照提示来即可.</p><p>编辑配置文件<code>/usr/bin/etc/stunnel.conf</code>, 如下所示:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cert = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">CAfile = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">socket = l:TCP_NODELAY=1</span><br><span class="line">socket = r:TCP_NODELAY=1</span><br><span class="line"></span><br><span class="line">pid = /tmp/stunnel.pid</span><br><span class="line">verify = 3</span><br><span class="line"></span><br><span class="line">setuid = stunnel</span><br><span class="line">setgid = stunnel</span><br><span class="line"></span><br><span class="line">compression = zlib</span><br><span class="line">delay = no</span><br><span class="line">sslVersion = TLSv1</span><br><span class="line">fips=no</span><br><span class="line"></span><br><span class="line">debug = 7</span><br><span class="line">syslog = no</span><br><span class="line">output = /usr/local/etc/stunnel/stunnel.log</span><br><span class="line"></span><br><span class="line">[s-openvpn]</span><br><span class="line">accept = 13579#监听端口</span><br><span class="line">connect = 127.0.0.1:4443#OpenVPN端口</span><br></pre></td></tr></table></figure></p><p>启动stunnel:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># stunnel</span><br></pre></td></tr></table></figure></p><p>查看OpenVPN和Stunnel是否正确执行, 检查相应端口:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># netstat -ntwla</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State      </span><br><span class="line">tcp        0      0 0.0.0.0:13579               0.0.0.0:*                   LISTEN    </span><br><span class="line">tcp        0      0 127.0.0.1:4443              127.0.0.1:50223             ESTABLISHED </span><br><span class="line"># lsof -i:4443 -n</span><br><span class="line">COMMAND   PID    USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME</span><br><span class="line">openvpn 25290    root    5u  IPv4 2982393      0t0  TCP *:pharos (LISTEN)</span><br><span class="line">openvpn 25290    root    8u  IPv4 3361561      0t0  TCP 127.0.0.1:pharos-&gt;127.0.0.1:50223 (ESTABLISHED)</span><br><span class="line">stunnel 26801 stunnel   10u  IPv4 3361560      0t0  TCP 127.0.0.1:50223-&gt;127.0.0.1:pharos (ESTABLISHED)</span><br></pre></td></tr></table></figure></p><p><strong>看到端口均已正确监听, 至此Server端配置完成</strong></p><h2 id="3-Router配置"><a href="#3-Router配置" class="headerlink" title="3.    Router配置"></a><code>3</code>.    Router配置</h2><p>安装好Linux系统后(Red hat或CentOS), 同步服务器时间(非常重要):<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># ntpdate time.nist.gov</span><br></pre></td></tr></table></figure></p><h3 id="3-1-安装Stunnel"><a href="#3-1-安装Stunnel" class="headerlink" title="3.1    安装Stunnel"></a><code>3.1</code>    安装Stunnel</h3><p>Router端需要首先安装Stunnel, 在本地开启加密链路, 透传OpenVPN加密端口4443, 然后OpenVPN才能开始接入:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install stunnel</span><br></pre></td></tr></table></figure><p>将Server端Stunnel证书传过来, 以便验证:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># scp root@server:/usr/local/etc/stunnel.pem root@router:/usr/local/etc/stunnel.pem</span><br></pre></td></tr></table></figure><p>开始进行stunnel配置, 配置文件<code>/usr/local/etc/stunnel.conf</code>:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pid = /tmp/stunnel.pid</span><br><span class="line">cert = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">socket = l:TCP_NODELAY=1</span><br><span class="line">socket = r:TCP_NODELAY=1</span><br><span class="line">verify = 3</span><br><span class="line">CAfile = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">client=yes</span><br><span class="line">compression = zlib</span><br><span class="line">ciphers = AES256-SHA</span><br><span class="line">delay = no</span><br><span class="line">failover = prio</span><br><span class="line">sslVersion = TLSv1</span><br><span class="line"></span><br><span class="line">output = /root/bin/logs/stunnel.log</span><br><span class="line">[s-openvpn]</span><br><span class="line">accept = 127.0.0.1:4443</span><br><span class="line">connect = server.ip.address:13579</span><br></pre></td></tr></table></figure><p>启动stunnel:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># stunnel</span><br></pre></td></tr></table></figure><h3 id="3-2-安装OpenVPN"><a href="#3-2-安装OpenVPN" class="headerlink" title="3.2    安装OpenVPN"></a><code>3.2</code>    安装OpenVPN</h3><p>下载安装OpenVPN, OpenVPN依赖lzo, 需要一同安装:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install lzo openvpn</span><br></pre></td></tr></table></figure><p>配置Router端配置文件<code>/etc/openvpn/hk.ovpn</code>:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dev tap#设备模式</span><br><span class="line">port 65530#本地监听端口</span><br><span class="line">proto tcp#协议</span><br><span class="line">client#服务模式:client</span><br><span class="line">tls-client#加密客户端</span><br><span class="line">ns-cert-type server</span><br><span class="line">remote 127.0.0.1 4443#Server端口, 由于使用Stunnel加密透传, 所以连接本地端口</span><br><span class="line">ca /etc/openvpn/ca/ca.crt#证书</span><br><span class="line">key /etc/openvpn/ca/client1.key#证书</span><br><span class="line">cert /etc/openvpn/ca/client1.crt#证书</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">#route-method exe</span><br><span class="line">#route-delay 2</span><br><span class="line">comp-lzo</span><br><span class="line">status /etc/openvpn/openvpn-status.log#状态日志</span><br><span class="line">log-append  /etc/openvpn/ca.log#执行日志</span><br><span class="line">verb 3</span><br></pre></td></tr></table></figure><p>启动OpenVPN:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># openvpn --daemon --config /etc/openvpn/hk.ovpn</span><br></pre></td></tr></table></figure><p>观察日志, 如果出现<code>“Initialization Sequence Completed”</code>则代表启动成功.</p><p>检查隧道:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ip addr</span><br><span class="line">11: tap0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN qlen 100</span><br><span class="line">    link/ether 06:10:50:e5:e5:2c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.31.188.2/24 brd 172.31.188.255 scope global tap0</span><br><span class="line">    inet6 fe80::410:50ff:fee5:e52c/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">       # ping 172.31.188.1</span><br><span class="line">PING 172.31.188.1 (172.31.188.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.31.188.1: icmp_seq=1 ttl=64 time=67.3 ms</span><br><span class="line">64 bytes from 172.31.188.1: icmp_seq=2 ttl=64 time=67.1 ms</span><br><span class="line">^C</span><br><span class="line">--- 172.31.188.1 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1588ms</span><br><span class="line">rtt min/avg/max/mdev = 67.183/67.284/67.386/0.278 ms</span><br></pre></td></tr></table></figure><p>链路通畅</p><h3 id="3-3-安装DNSmasq"><a href="#3-3-安装DNSmasq" class="headerlink" title="3.3    安装DNSmasq"></a><code>3.3</code>    安装DNSmasq</h3><p>Router若要进行翻墙, 需要使用国外DNS, 而浏览国内网站时, 如果使用国外DNS, 会造成将访问导向国外站点, 造成访问速度变慢, 所以此方案使用DNSmasq解决此问题.</p><p>同时DNSmasq也是一个轻量级DHCP服务器, 非常方便好用.</p><p>安装DNSmasq:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install dnsmasq</span><br></pre></td></tr></table></figure><p>编辑DNSmasq配置文件<code>/etc/dnsmasq.conf</code>, 假设Router本地IP是10.2.166.10, 本地分发网段是10.2.166.0/24, 则配置如下:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># DHCP config</span><br><span class="line">expand-hosts</span><br><span class="line">domain=archean.me</span><br><span class="line"># DHCP Range</span><br><span class="line">dhcp-range=10.2.166.50,10.2.166.150,12h#DHCP地址池</span><br><span class="line"># DHCP route</span><br><span class="line">dhcp-option=3,10.2.166.10#路由</span><br><span class="line"># Apple ntp server</span><br><span class="line">dhcp-option=option:ntp-server,10.3.1.233#ntp时间服务器</span><br><span class="line"></span><br><span class="line"># DNS server</span><br><span class="line">no-resolv</span><br><span class="line">no-poll</span><br><span class="line">server=8.8.8.8</span><br><span class="line">server=8.8.4.4</span><br><span class="line">conf-dir=/etc/dnsmasq.d</span><br><span class="line"></span><br><span class="line"># AppleTV trailers</span><br><span class="line">address=/trailers.apple.com/180.153.225.136</span><br><span class="line"></span><br><span class="line"># Static IPs</span><br><span class="line"># dhcp-host=xx:xx:xx:xx:xx:xx,10.2.166.121</span><br></pre></td></tr></table></figure><p>配置分类解析配置文件<code>/etc/dnsmasq.d/china.conf</code>, 以使常用域名走国内DNS解析, 举例如下, 根据自身情况更改:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># server=/domain.name/dns.server</span><br><span class="line">server=/115.com/114.114.114.114</span><br><span class="line">server=/123u.com/114.114.114.114</span><br><span class="line">server=/126.com/114.114.114.114</span><br><span class="line">server=/126.net/114.114.114.114</span><br><span class="line">server=/163.com/114.114.114.114</span><br><span class="line">server=/17173.com/114.114.114.114</span><br><span class="line">server=/17cdn.com/114.114.114.114</span><br><span class="line">server=/51.la/114.114.114.114</span><br><span class="line">server=/6rooms.com/114.114.114.114</span><br><span class="line">server=/91.com/114.114.114.114</span><br></pre></td></tr></table></figure><p><strong>至此准备工作完成, 可以启动路由器了</strong></p><h3 id="3-4-启动路由器"><a href="#3-4-启动路由器" class="headerlink" title="3.4    启动路由器"></a><code>3.4</code>    启动路由器</h3><p><strong>思路</strong></p><p>默认路由为OpenVPN Server端私网IP, chnroute生成的<a href="http://www.lailai-start.com/CN" target="_blank" rel="noopener">3000条国内路由</a>走国内链路, 以达到分流/翻墙的目的.</p><p><strong>步骤:</strong></p><ul><li>启动Stunnel, 启动DNSmasq</li><li>开启linux内核转发功能</li><li>启动OpenVPN</li><li>增加3000条国内路由(<a href="http://www.lailai-start.com/CN" target="_blank" rel="noopener">点这里下载</a>)</li><li>增加默认路由, 增加下一跳为OpenVPN Server端私网IP</li></ul><p>将步骤编写成脚本, 如下:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Stunnel up</span><br><span class="line">/usr/bin/stunnel</span><br><span class="line">/usr/sbin/dnsmasq</span><br><span class="line"></span><br><span class="line"># date ntp time</span><br><span class="line">ntpdate ntp.server.name</span><br><span class="line">/sbin/route add -net 10.0.0.0/8 gw 10.2.166.1</span><br><span class="line">/sbin/route add -host server.ip.address gw 10.2.166.1</span><br><span class="line"></span><br><span class="line"># iptables NAT</span><br><span class="line">/sbin/iptables -t nat -A POSTROUTING -o tap0 -j MASQUERADE</span><br><span class="line">sysctl -w net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line"># start Openvpn</span><br><span class="line">killall openvpn</span><br><span class="line">/usr/local/sbin/openvpn --daemon --config /etc/openvpn/hk.ovpn</span><br><span class="line">sleep 5</span><br><span class="line"># Chnrouters</span><br><span class="line">for i in `cat /root/bin/CN` ; do /sbin/route add -net $i gw 10.2.166.1 ; done</span><br><span class="line">/sbin/route del default</span><br><span class="line">/sbin/route add default gw 10.2.166.1</span><br><span class="line">/sbin/route add default gw 172.31.188.1</span><br></pre></td></tr></table></figure><p>启动脚本, Router环境搭建完成, 国外网络访问测试:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># tracert 8.8.8.8</span><br><span class="line">traceroute to 8.8.8.8 (8.8.8.8), 30 hops max, 60 byte packets</span><br><span class="line"> 1  172.31.188.1 (172.31.188.1)  68.963 ms  68.913 ms  68.914 ms</span><br><span class="line"> 2  103.30.4.1 (103.30.4.1)  109.650 ms  109.651 ms  109.645 ms</span><br><span class="line"> 3  172.16.0.2 (172.16.0.2)  109.410 ms  109.454 ms  109.448 ms</span><br><span class="line"> 4  gi1-26.br02.hkg04.pccwbtn.net (63.218.241.1)  109.384 ms  109.384 ms  109.465 ms</span><br><span class="line"> 5  72.14.196.197 (72.14.196.197)  109.415 ms  109.381 ms  109.344 ms</span><br><span class="line"> 6  209.85.241.56 (209.85.241.56)  109.368 ms 209.85.241.58 (209.85.241.58)  105.488 ms  149.385 ms</span><br><span class="line"> 7  216.239.43.17 (216.239.43.17)  108.792 ms  68.841 ms 209.85.253.69 (209.85.253.69)  69.430 ms</span><br><span class="line"> 8  * * *</span><br><span class="line"> 9  google-public-dns-a.google.com (8.8.8.8)  108.102 ms  107.936 ms  107.819 ms</span><br></pre></td></tr></table></figure><p>可以看到直接走OpenVPN私网IP出去, 国内网络访问测试:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># traceroute www.baidu.com</span><br><span class="line">traceroute to www.baidu.com (115.239.210.26), 30 hops max, 60 byte packets</span><br><span class="line"> 1  10.2.166.1 (10.2.166.1)  2.267 ms  2.470 ms  2.623 ms</span><br><span class="line"> 2  10.2.255.254 (10.2.255.254)  2.180 ms  2.492 ms  2.648 ms</span><br><span class="line"> 3  * * *</span><br><span class="line"> 4  * * *</span><br><span class="line"> 5  * * *</span><br><span class="line"> 6  123.125.40.254 (123.125.40.254)  2.714 ms  2.634 ms  2.883 ms</span><br><span class="line"> 7  61.49.44.65 (61.49.44.65)  1.459 ms  1.448 ms  1.521 ms</span><br><span class="line"> 8  61.148.160.5 (61.148.160.5)  1.443 ms  1.466 ms  1.459 ms</span><br><span class="line"> 9  124.65.60.77 (124.65.60.77)  3.258 ms  5.805 ms  5.790 ms</span><br><span class="line"> 10  123.126.0.85 (123.126.0.85)  3.392 ms  3.202 ms  3.245 ms</span><br><span class="line">11  123.126.0.85 (123.126.0.85)  3.214 ms  5.487 ms  3.913 ms</span><br><span class="line">12  219.158.35.90 (219.158.35.90)  71.347 ms  71.338 ms  71.337 ms</span><br></pre></td></tr></table></figure><p>国内链路则直接走原本的网络环境出去.</p><h3 id="3-5-配置监控脚本"><a href="#3-5-配置监控脚本" class="headerlink" title="3.5    配置监控脚本"></a><code>3.5</code>    配置监控脚本</h3><p>由于国际出口不一定稳定, OpenVPN有可能会间歇性断掉, 如果发生此情况, 则会造成默认路由不可达, 从而导致国内网站浏览也会出现问题, 所以配置监控脚本, 一旦国际链路抽风, 则立刻将路由切换至国内.</p><p>脚本内容如下:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">       ip=&quot;172.31.188.1&quot;</span><br><span class="line">       i=-1</span><br><span class="line">       j=-1</span><br><span class="line">       while : ; do</span><br><span class="line">               ping $ip -c 5 -w 30</span><br><span class="line">               if [ $? -ge &quot;1&quot; ]; then</span><br><span class="line">               route del default gw $ip</span><br><span class="line">       j=-1</span><br><span class="line">                   i=$((i+1))</span><br><span class="line">               txt=`date +%F&quot; &quot;%X`&quot; Ping $ip timed out.&quot;</span><br><span class="line">               (($i%30==0)) &amp;&amp; echo $txt &gt;&gt; /root/bin/logs/checkip.log </span><br><span class="line">       (($i%30==0)) &amp;&amp; echo $txt | mailx -s &quot;VPN disconnected&quot; admin@domain.com</span><br><span class="line">               else</span><br><span class="line">                   route add default gw $ip</span><br><span class="line">                   i=-1</span><br><span class="line">       j=$((j+1))</span><br><span class="line">       txt=`date +%F&quot; &quot;%X`&quot; Ping $ip OK.&quot;</span><br><span class="line">       (($j%30==0)) &amp;&amp; echo $txt &gt;&gt; /root/bin/logs/checkip.log</span><br><span class="line">       (($j%100000==0)) &amp;&amp; echo $txt | mailx -s &quot;VPN OK.&quot; admin@domain.com</span><br><span class="line">               fi</span><br><span class="line">       sleep 10</span><br><span class="line">       done</span><br></pre></td></tr></table></figure><p>后台启动此脚本, 则会每10秒监控一次出国链路, 如果断掉, 将会把路由切至国内, 不影响正常上网; 如果出国链路长期无法恢复, 则每5分钟给管理员发送一封告警邮件.</p><h2 id="4-Client"><a href="#4-Client" class="headerlink" title="4.    Client"></a><code>4</code>.    Client</h2><p>客户端接入路由器所在交换机后, 配置为自动获取IP地址, 即可进行翻墙.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Arthor:    Archean Zhang&lt;/p&gt;
&lt;p&gt;Email:    &lt;a href=&quot;mailto:zephyr422@gmail.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zephyr422@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Version:    1.0.1&lt;/p&gt;
&lt;p&gt;Date:        2013/8/16&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;长期被GFW困扰, 我终于忍不住动手了: 把家里的Raspberry Pi和与自由世界的主机建立OpenVPN over Stunnel的链路, 根据大中华3000条路由来匹配, 国外网站自动走OpenVPN出去以实现翻墙.&lt;/p&gt;
&lt;p&gt;以下文章是基于一台Linux服务器(CentOS 6.4)撰写的, 将下面&lt;code&gt;Router&lt;/code&gt;的换成Raspberry Pi也一样.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Squid与Stunnel构建安全的http代理服务器</title>
    <link href="https://archeanz.com/2013/10/16/safe-http-proxy-over-squid-and-stunnel/"/>
    <id>https://archeanz.com/2013/10/16/safe-http-proxy-over-squid-and-stunnel/</id>
    <published>2013-10-16T13:26:07.000Z</published>
    <updated>2019-03-11T14:46:51.334Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/1519029/39092612-9a633210-4644-11e8-9f55-e238e0ef516e.jpg" alt="Squid" title="Squid"><br>使用Squid在服务器端打开一个http 验证的代理端口, 同时用服务器上的Stunnel进行转发, 与客户端的Stunnel通过SSL链接, 达到代理的目的.</p><p>也可以使用客户端的Stunnel与Squid通过SSL直接相连.</p><p>本方法使用前者.<br><a id="more"></a></p><h1 id="1-服务器端配置"><a href="#1-服务器端配置" class="headerlink" title="1. 服务器端配置"></a>1. 服务器端配置</h1><p>服务器环境:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># lsb_release -a</span><br><span class="line">LSB Version::core-4.0-ia32:core-4.0-noarch:graphics-4.0-ia32:graphics-4.0-noarch:printing-4.0-ia32:printing-4.0-noarch</span><br><span class="line">Distributor ID:CentOS</span><br><span class="line">Description:CentOS Linux release 6.0 (Final)</span><br><span class="line">Release:6.0</span><br><span class="line">Codename:Final</span><br><span class="line"># uname -a</span><br><span class="line">Linux jb1.archean.me 2.6.32-71.el6.i686 #1 SMP Fri Nov 12 04:17:17 GMT 2010 i686 i686 i386 GNU/Linux</span><br></pre></td></tr></table></figure><h2 id="1-1-安装Squid"><a href="#1-1-安装Squid" class="headerlink" title="1.1 安装Squid"></a>1.1 安装Squid</h2><p>下载squid 3.2.8</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wget http://www.squid-cache.org/Versions/v3/3.2/squid-3.2.8.tar.gz</span><br></pre></td></tr></table></figure><p>可以使用CentOS的Yum安装工具, 不过我更喜欢编译安装(提前准备好编译环境, Gcc, openssl等):</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># tar zxvf squid-3.2.8.tar.gz</span><br><span class="line"># cd squid-3.2.8</span><br><span class="line"># ./configure --prefix=/usr/local --enable-basic-auth-helpers=NCSA</span><br><span class="line"># make</span><br><span class="line"># make install</span><br></pre></td></tr></table></figure><h2 id="1-2-配置Squid"><a href="#1-2-配置Squid" class="headerlink" title="1.2 配置Squid"></a>1.2 配置Squid</h2><p>这个拓扑结构只需要Squid做简单的http代理, 所以无需SSL.</p><p>squid的配置文件在<code>/usr/local/etc/squid.conf</code></p><p>备份之后, 将其按下面修改, 为防止被别的机器滥用, 只监听127.0.0.1:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">###/usr/local/etc/squid.conf</span><br><span class="line">###2013-1-27 19:56 v0.0.1 for squid 3.2.6</span><br><span class="line">#Xu Zhang &lt;zephyr422@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">visible_hostname Archean.me</span><br><span class="line">cache_mgr zephyr422@gmail.com</span><br><span class="line">http_port 127.0.0.1:3177</span><br><span class="line">icp_port 0</span><br><span class="line">cache_mem 256 MB</span><br><span class="line">dns_nameservers 8.8.8.8 8.8.4.4</span><br><span class="line"></span><br><span class="line">coredump_dir /usr/local/var/cache/squid</span><br><span class="line">access_log /usr/local/var/logs/squid_access.log</span><br><span class="line">cache_log /usr/local/var/logs/squid_cache.log</span><br><span class="line"></span><br><span class="line">auth_param basic program /usr/local/libexec/basic_ncsa_auth /usr/local/etc/squid.passwd #使用 HTTP 基本验证</span><br><span class="line">auth_param basic children 5</span><br><span class="line">auth_param basic realm Archean&apos;s GFW Breaker Proxy, to forward, please input &quot;Username/Password&quot;.</span><br><span class="line">auth_param basic credentialsttl 7 days</span><br><span class="line">auth_param basic casesensitive off</span><br><span class="line"></span><br><span class="line">acl password proxy_auth REQUIRED</span><br><span class="line">acl localnet src 10.0.0.0/8# RFC1918 possible internal network</span><br><span class="line">acl localnet src 172.16.0.0/12# RFC1918 possible internal network</span><br><span class="line">acl localnet src 192.168.0.0/16# RFC1918 possible internal network</span><br><span class="line">acl localnet src fc00::/7       # RFC 4193 local private network range</span><br><span class="line">acl localnet src fe80::/10      # RFC 4291 link-local (directly plugged) machines</span><br><span class="line">acl SSL_ports port 443</span><br><span class="line">acl Safe_ports port 80# http</span><br><span class="line">acl Safe_ports port 21# ftp</span><br><span class="line">acl Safe_ports port 443# https</span><br><span class="line">acl Safe_ports port 70# gopher</span><br><span class="line">acl Safe_ports port 210# wais</span><br><span class="line">acl Safe_ports port 1025-65535# unregistered ports</span><br><span class="line">acl Safe_ports port 280# http-mgmt</span><br><span class="line">acl Safe_ports port 488# gss-http</span><br><span class="line">acl Safe_ports port 591# filemaker</span><br><span class="line">acl Safe_ports port 777# multiling http</span><br><span class="line">acl CONNECT method CONNECT</span><br><span class="line"></span><br><span class="line">http_access allow password</span><br><span class="line"></span><br><span class="line">http_access deny !Safe_ports</span><br><span class="line">http_access deny CONNECT !SSL_ports</span><br><span class="line">http_access allow localnet</span><br><span class="line">http_access allow localhost</span><br><span class="line"></span><br><span class="line">http_access deny all</span><br></pre></td></tr></table></figure><p>检查配置有没有问题:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># squid -k check</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># squid -k parse</span><br></pre></td></tr></table></figure><p>生成密码文件(<code>-c</code>), 创建账户. (如果没有<code>htpasswd</code>需要安装 httpd, 略)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># htpasswd -c /usr/local/etc/squid.passwd archean</span><br><span class="line">new password</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>初始化cache目录</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># squid -z</span><br></pre></td></tr></table></figure><p>一旦你已经初始化cache目录，就可以在终端窗口里运行squid，将日志记录到标准错误。这样，就能轻易的定位任何错误或问题，并且确认squid是否成功启动。使用-N选项来保持squid在前台运行，-d1选项在标准错误里显示1级别的调试信息。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># squid -N -d1</span><br></pre></td></tr></table></figure><p>启动squid:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># squid</span><br></pre></td></tr></table></figure><p>检查是否启动成功, <code>ps -ef | grep squid</code> 或 <code>lsof -i:3177</code></p><p>模拟测试客户端连接:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># squidclient -p 3177 http://www.squid-cache.org/</span><br></pre></td></tr></table></figure><p>如期返回了html信息, 说明Squid已成功启动.</p><h2 id="1-3-安装Stunnel"><a href="#1-3-安装Stunnel" class="headerlink" title="1.3 安装Stunnel"></a>1.3 安装Stunnel</h2><p>下载稳定版Stunnel</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wget https://www.stunnel.org/downloads/stunnel-4.56.tar.gz</span><br></pre></td></tr></table></figure><p>创建Stunnel用户:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /usr/sbin/groupadd -g 122 stunnel</span><br><span class="line"># /usr/sbin/useradd -c stunnel -d /nonexistent -m -g 122 -u 122 stunnel</span><br></pre></td></tr></table></figure><p>安装:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># tar zxvf stunnel-4.56.tar.gz</span><br><span class="line"># cd stunnel-4.56</span><br><span class="line"># ./configure --prefix=/usr/local</span><br><span class="line"># make</span><br><span class="line"># makeinstall</span><br></pre></td></tr></table></figure><p>安装过程通常会创建自签名证书, 会放到<code>/usr/local/etc/stunnel/stunnel.pem</code>可以直接使用(有效期一年). 使用下面的命令检查证书详细内容:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># openssl x509 -subject -dates -fingerprint -in stunnel.pem </span><br><span class="line">subject= /C=CN/ST=Beijing/L=Beijing/O=Archean Inc/OU=Archean Inc/CN=archean.me</span><br><span class="line">notBefore=Apr 20 02:05:24 2013 GMT</span><br><span class="line">notAfter=Apr 20 02:05:24 2014 GMT</span><br><span class="line">SHA1 Fingerprint=87:F8:6E:05:B8:9C:BC:A1:EA:15:B7:C9:B4:B2:75:FF:8A:CA:C5:FA</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">xxx</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure><p>给证书生成 Diffie-Hellman 部分</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># openssl gendh 512&gt;&gt; stunnel.pem</span><br></pre></td></tr></table></figure><p>这在4.x版本的stunnel上好像是必须的.</p><p>如果想要自己生成证书, 命令如下:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># openssl req -new -x509 -days 365 -nodes -config openssl.cnf -out stunnel.pem -keyout stunnel.pem</span><br></pre></td></tr></table></figure><h2 id="1-4-配置Stunnel"><a href="#1-4-配置Stunnel" class="headerlink" title="1.4 配置Stunnel"></a>1.4 配置Stunnel</h2><p>在<code>/usr/local/etc/stunnel/</code>下创建stunnel.conf, 写入如下配置:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cert = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">CAfile = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">socket = l:TCP_NODELAY=1</span><br><span class="line">socket = r:TCP_NODELAY=1</span><br><span class="line"></span><br><span class="line">;;;chroot = /var/run/stunnel</span><br><span class="line">pid = /tmp/stunnel.pid</span><br><span class="line">verify = 3</span><br><span class="line"></span><br><span class="line">;;; CApath = certs</span><br><span class="line">;;; CRLpath = crls</span><br><span class="line">;;; CRLfile = crls.pem</span><br><span class="line"></span><br><span class="line">setuid = stunnel</span><br><span class="line">setgid = stunnel</span><br><span class="line"></span><br><span class="line">;;; client=yes</span><br><span class="line">compression = zlib</span><br><span class="line">;;; taskbar = no</span><br><span class="line">delay = no</span><br><span class="line">;;; failover = rr</span><br><span class="line">;;; failover = prio</span><br><span class="line">sslVersion = TLSv1</span><br><span class="line">fips=no</span><br><span class="line"></span><br><span class="line">debug = 7</span><br><span class="line">syslog = no</span><br><span class="line">output = stunnel.log</span><br><span class="line"></span><br><span class="line">[sproxy]</span><br><span class="line">accept = 34567</span><br><span class="line">connect = 127.0.0.1:3177</span><br></pre></td></tr></table></figure><p>此时便可启动stunnel:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># stunnel</span><br></pre></td></tr></table></figure><p>检查是否运行:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ps -ef | grep stunnel</span><br><span class="line"># lsof -i:34567</span><br></pre></td></tr></table></figure><h2 id="1-5-将Squid和Stunnel加入开机启动项"><a href="#1-5-将Squid和Stunnel加入开机启动项" class="headerlink" title="1.5 将Squid和Stunnel加入开机启动项"></a>1.5 将Squid和Stunnel加入开机启动项</h2><p>略</p><h1 id="2-客户端配置"><a href="#2-客户端配置" class="headerlink" title="2. 客户端配置"></a>2. 客户端配置</h1><h2 id="2-1-linux客户端使用stunnel与服务器进行安全连接"><a href="#2-1-linux客户端使用stunnel与服务器进行安全连接" class="headerlink" title="2.1 linux客户端使用stunnel与服务器进行安全连接"></a>2.1 linux客户端使用stunnel与服务器进行安全连接</h2><p>安装Stunnel</p><p>与服务器完全相同, 略.</p><h2 id="2-2-配置客户端Stunnel"><a href="#2-2-配置客户端Stunnel" class="headerlink" title="2.2 配置客户端Stunnel"></a>2.2 配置客户端Stunnel</h2><p>将服务器生成的证书传到客户端中:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/etc/stunnel</span><br><span class="line"># scp root@jb1.archean.me:/usr/local/etc/stunnel/stunnel.pem ./</span><br></pre></td></tr></table></figure><p>创建配置文件</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim stunnel.conf</span><br></pre></td></tr></table></figure><p>内容如下:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">id = /tmp/stunnel.pid</span><br><span class="line">cert = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">socket = l:TCP_NODELAY=1</span><br><span class="line">socket = r:TCP_NODELAY=1</span><br><span class="line">verify = 2</span><br><span class="line">CAfile = /usr/local/etc/stunnel/stunnel.pem</span><br><span class="line">client=yes</span><br><span class="line">compression = zlib</span><br><span class="line">ciphers = AES256-SHA</span><br><span class="line">delay = no</span><br><span class="line">failover = prio</span><br><span class="line">sslVersion = TLSv1</span><br><span class="line">fips = no</span><br><span class="line">[sproxy]</span><br><span class="line">accept  = 0.0.0.0:7071</span><br><span class="line">connect = jb1.archean.me:34567</span><br></pre></td></tr></table></figure><p>其中accept是本地代理监听地址, 如不对外提供服务则改为<code>accept = 127.0.0.1:7071</code></p><p>启动stunnel:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># /usr/local/bin/stunnel</span><br></pre></td></tr></table></figure><p>至此, 配置完全结束, 可以通过使用<code>Client.IP.Address:7071</code>代理上网</p><h2 id="2-3-结语"><a href="#2-3-结语" class="headerlink" title="2.3 结语"></a>2.3 结语</h2><p>参考资料:</p><p><a href="http://home.arcor.de/pangj/squid/index.html" target="_blank" rel="noopener">Squid权威指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/1519029/39092612-9a633210-4644-11e8-9f55-e238e0ef516e.jpg&quot; alt=&quot;Squid&quot; title=&quot;Squid&quot;&gt;&lt;br&gt;使用Squid在服务器端打开一个http 验证的代理端口, 同时用服务器上的Stunnel进行转发, 与客户端的Stunnel通过SSL链接, 达到代理的目的.&lt;/p&gt;
&lt;p&gt;也可以使用客户端的Stunnel与Squid通过SSL直接相连.&lt;/p&gt;
&lt;p&gt;本方法使用前者.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="https://archeanz.com/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>为nginx配置https并自签名证书</title>
    <link href="https://archeanz.com/2013/10/16/enable-nginx-ssl/"/>
    <id>https://archeanz.com/2013/10/16/enable-nginx-ssl/</id>
    <published>2013-10-16T12:44:25.000Z</published>
    <updated>2019-03-10T09:06:17.550Z</updated>
    
    <content type="html"><![CDATA[<p>为了使网站可以使用加密的方式访问, 我们有时需要配置https, 此文章简单介绍一下方法.</p><p>##把证书准备好。</p><p>###制作CA证书：</p><p>ca.key CA私钥：</p><pre><code>openssl genrsa -des3 -out ca.key 2048</code></pre><p>制作解密后的CA私钥（一般无此必要）：</p><pre><code>openssl rsa -in ca.key -out ca_decrypted.key</code></pre><p>ca.crt CA根证书（公钥）：</p><pre><code>openssl req -new -x509 -days 7305 -key ca.key -out ca.crt</code></pre><a id="more"></a><p>###制作生成网站的证书并用CA签名认证<br>在这里，假设网站域名为<code>blog.archean.me</code></p><p>生成blog.archean.me证书私钥：</p><pre><code>openssl genrsa -des3 -out blog.archean.me.pem 1024</code></pre><p>制作解密后的blog.archean.me证书私钥：</p><pre><code>openssl rsa -in blog.archean.me.pem -out blog.archean.me.key</code></pre><p>生成签名请求：</p><pre><code>openssl req -new -key blog.archean.me.pem -out blog.archean.me.csr</code></pre><p>在common name中填入网站域名，如blog.archean.me即可生成改站点的证书，同时也可以使用泛域名如<code>*.archean.me</code>来生成所有二级域名可用的网站证书。</p><p>用CA进行签名：</p><pre><code>openssl ca -policy policy_anything -days 1460 -cert ca.crt -keyfile ca.key -in blog.archean.me.csr -out blog.archean.me.crt</code></pre><p>其中，policy参数允许签名的CA和网站证书可以有不同的国家、地名等信息，days参数则是签名时限。<br>如果在执行签名命令时，出现<code>I am unable to access the ../../CA/newcerts directory</code></p><pre><code>修改/etc/pki/tls/openssl.cnf中“dir = ./CA”</code></pre><p>然后：</p><pre><code>mkdir -p CA/newcertstouch CA/index.txttouch CA/serialecho “01″ &gt; CA/serial</code></pre><p>再重新执行签名命令。</p><p>最后，把ca.crt的内容粘贴到blog.archean.me.crt后面。这个比较重要！因为不这样做，可能会有某些浏览器不支持。<br>好了，现在https需要到的网站私钥blog.archean.me.key和网站证书blog.archean.me.crt都准备完毕。接下来开始配置服务端。</p><p>##配置nginx<br>新开一个虚拟主机，并在server{}段中设置：</p><pre><code>listen 443;ssl on;ssl_certificate /path/to/blog.archean.me.crt;ssl_certificate_key /path/to/blog.archean.me.key;</code></pre><p>其中的路径是刚刚生成的网站证书的路径。</p><p>然后使用一下命令检测配置和重新加载nginx：</p><p>检测配置：</p><pre><code>nginx -t</code></pre><p>重新加载：</p><pre><code>nginx -s reload</code></pre><p>在<a href="http://nginx.org/en/docs/http/configuring_https_servers.html" target="_blank" rel="noopener">这里</a>是nginx官方的关于https的文档，可以作为参考。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了使网站可以使用加密的方式访问, 我们有时需要配置https, 此文章简单介绍一下方法.&lt;/p&gt;
&lt;p&gt;##把证书准备好。&lt;/p&gt;
&lt;p&gt;###制作CA证书：&lt;/p&gt;
&lt;p&gt;ca.key CA私钥：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;openssl genrsa -des3 -out ca.key 2048
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;制作解密后的CA私钥（一般无此必要）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;openssl rsa -in ca.key -out ca_decrypted.key
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ca.crt CA根证书（公钥）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;openssl req -new -x509 -days 7305 -key ca.key -out ca.crt
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="linux" scheme="https://archeanz.com/categories/linux/"/>
    
      <category term="web" scheme="https://archeanz.com/categories/linux/web/"/>
    
    
  </entry>
  
</feed>
